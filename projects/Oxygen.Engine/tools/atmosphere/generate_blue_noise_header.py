#!/usr/bin/env python3
"""
Generate a 3D blue-noise-like volume and emit BlueNoiseData.h.

Supports:
- Synthetic generation (default): FFT high-pass + rank remap per slice.
- Atlas import (--atlas): split a tiled grayscale atlas into slices.
  Atlas must be (tile_size * grid) x (tile_size * grid) with grid^2 >= slices.
"""

from __future__ import annotations

import argparse
from pathlib import Path

import numpy as np
from PIL import Image
import imageio.v3 as iio


HEADER_PROLOG = """//===----------------------------------------------------------------------===//
// Distributed under the 3-Clause BSD License. See accompanying file LICENSE or
// copy at https://opensource.org/licenses/BSD-3-Clause.
// SPDX-License-Identifier: BSD-3-Clause
//===----------------------------------------------------------------------===//

// Generated by tools/atmosphere/generate_blue_noise_header.py
// Format: R8_UNORM (1 byte/texel), dimensions: {size}x{size}x{slices}
// Slice layout: contiguous, each slice row-major.

#pragma once
#include <cstdint>

namespace oxygen::engine::resources {{

static constexpr uint32_t kBlueNoiseSize = {size};
static constexpr uint32_t kBlueNoiseSlices = {slices};
static constexpr uint32_t kBlueNoiseDataSize = {data_size};

// clang-format off
static const uint8_t TextureData_BlueNoise[] = {{
"""

HEADER_EPILOG = """
};
// clang-format on

} // namespace oxygen::engine::resources
"""


def rank_to_u8(tile: np.ndarray) -> np.ndarray:
    flat = tile.reshape(-1)
    order = np.argsort(flat, kind="mergesort")
    ranks = np.empty_like(order)
    ranks[order] = np.arange(order.size, dtype=np.int32)
    out = np.round(ranks * (255.0 / max(1, order.size - 1))).astype(np.uint8)
    return out.reshape(tile.shape)


def make_blue_like_slice(size: int, rng: np.random.Generator) -> np.ndarray:
    # White noise in normal distribution.
    n = rng.standard_normal((size, size), dtype=np.float32)

    # Frequency-domain high-pass shaping (blue-ish spectrum).
    f = np.fft.rfft2(n)
    ky = np.fft.fftfreq(size).reshape(-1, 1)
    kx = np.fft.rfftfreq(size).reshape(1, -1)
    radius = np.sqrt(kx * kx + ky * ky).astype(np.float32)
    radius[0, 0] = 0.0
    gain = np.sqrt(radius + 1e-8)
    shaped = np.fft.irfft2(f * gain, s=(size, size)).real.astype(np.float32)

    # Rank remap ensures near-uniform [0..255] distribution per slice.
    return rank_to_u8(shaped)


def generate_synthetic(size: int, slices: int, seed: int) -> np.ndarray:
    vol = np.empty((slices, size, size), dtype=np.uint8)
    for z in range(slices):
        rng = np.random.default_rng(seed + z * 977 + 17)
        vol[z] = make_blue_like_slice(size, rng)
    return vol


def generate_from_atlas(atlas_path: Path, size: int, slices: int) -> np.ndarray:
    # Prefer PIL for common image formats; fallback to imageio for EXR and others.
    arr: np.ndarray
    try:
        img = Image.open(atlas_path).convert("F")
        arr = np.array(img, dtype=np.float32)
    except Exception:
        raw = iio.imread(atlas_path)
        arr = np.array(raw, dtype=np.float32)
        if arr.ndim == 3:
            # Use luminance from RGB[A] atlas.
            arr = arr[..., :3].mean(axis=2)

    h, w = arr.shape
    if h != w:
        raise ValueError(f"Atlas must be square, got {w}x{h}")

    if h % size != 0:
        raise ValueError(f"Atlas dimension {h} must be divisible by tile size {size}")
    grid = h // size
    if grid * grid < slices:
        raise ValueError(f"Atlas has {grid*grid} tiles but need {slices}")

    vol = np.empty((slices, size, size), dtype=np.uint8)
    idx = 0
    for gy in range(grid):
        for gx in range(grid):
            if idx >= slices:
                break
            tile = arr[gy * size:(gy + 1) * size, gx * size:(gx + 1) * size]
            # Normalize each tile then rank-remap for stable R8 usage.
            tmin = float(tile.min())
            tmax = float(tile.max())
            if tmax > tmin:
                tile = (tile - tmin) / (tmax - tmin)
            vol[idx] = rank_to_u8(tile)
            idx += 1
        if idx >= slices:
            break
    return vol


def emit_header(path: Path, vol: np.ndarray) -> None:
    slices, size_h, size_w = vol.shape
    assert size_h == size_w
    size = size_h
    flat = vol.reshape(-1)

    prolog = HEADER_PROLOG.format(
        size=size,
        slices=slices,
        data_size=flat.size,
    )

    lines: list[str] = [prolog]
    per_line = 16
    for i in range(0, flat.size, per_line):
        chunk = flat[i:i + per_line]
        text = ", ".join(f"0x{int(v):02x}" for v in chunk)
        lines.append(f"    {text},\n")
    lines.append(HEADER_EPILOG)
    path.write_text("".join(lines), encoding="utf-8")


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--output",
        type=Path,
        default=Path("src/Oxygen/Renderer/Internal/BlueNoiseData.h"),
        help="Header path to write",
    )
    ap.add_argument("--size", type=int, default=64)
    ap.add_argument("--slices", type=int, default=49)
    ap.add_argument("--seed", type=int, default=1337)
    ap.add_argument(
        "--atlas",
        type=Path,
        default=None,
        help="Optional tiled atlas image to import (e.g. 448x448 for 7x7 of 64x64)",
    )
    args = ap.parse_args()

    if args.atlas is not None:
        vol = generate_from_atlas(args.atlas, args.size, args.slices)
        source = f"atlas:{args.atlas}"
    else:
        vol = generate_synthetic(args.size, args.slices, args.seed)
        source = f"synthetic(seed={args.seed})"

    emit_header(args.output, vol)
    print(
        f"Generated {args.output} from {source} "
        f"({args.size}x{args.size}x{args.slices}, bytes={vol.size})"
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
