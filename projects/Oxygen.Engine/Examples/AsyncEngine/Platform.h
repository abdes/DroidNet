#pragma once

#include <array>
#include <chrono>
#include <optional>

#include "Oxygen/Composition/Composition.h"
#include "Oxygen/OxCo/Co.h"
#include "Oxygen/OxCo/Concepts/Awaitable.h"
#include "Oxygen/OxCo/Event.h"
#include "Oxygen/OxCo/Nursery.h"
#include "Oxygen/OxCo/ParkingLot.h"
#include "Oxygen/OxCo/Shared.h"
#include "Oxygen/OxCo/asio.h"
#include "PlatformEvent.h"
#include <queue>

namespace oxygen {

class Platform;

namespace platform {
    class AsyncOps : public Component {
        OXYGEN_COMPONENT(AsyncOps)
    public:
        //! A utility function, returning an awaitable suspending the caller for
        //! a specified duration. Suitable for use with `AnyOf()` etc.
        auto SleepFor(std::chrono::microseconds delay)
        {
            return co::SleepFor(io_, delay);
        }

        auto PollOne() -> size_t;

    private:
        asio::io_context io_;
    };

    class EventPump : public Component {
        OXYGEN_COMPONENT(EventPump)
    public:
        using SharedProducer = std::function<co::Co<PlatformEvent>()>;

        //! Called as part of the main loop to check for pending platform
        //! events, and if any are found, to remove and asynchronously process
        //! __only__ the next one.
        /*!
         \note This method is not asynchronous and needs to complete quickly.
               When at least one event is ready, it resumes `PumpEvents()`,
               which will do the actual processing asynchronously. This
               machinery is internal to the platform. Externally, interested
               parties should await the awaitable appropriate for the event type
               they are interested in.
        */
        auto PollOne() -> bool;

        //! Suspends the caller until a platform event is available.
        /*!
         Uses a double-buffering technique to ensure that the event is not
         missed by all tasks waiting for it, and will allow the tasks that
         complete first to wait for the next event.
        */
        auto WaitForNextEvent() -> co::Awaitable<PlatformEvent> auto
        {
            if (!initialized_) {
                BootStrap();
            }
            return aw_events_[aw_event_index_];
        }

    private:
        void BootStrap(size_t index = 0);

        //! Waits for platform events, and when available, translates them into
        //! specific event types and awakes any tasks waiting for them.
        /*!
         This is the asynchronous part of the platform event processing. It is
         constantly waiting for platform events, and when one is available, it
         translates it into a specific event type and awakes any tasks waiting
         for it.

         This method is resumed by the `PollOne()` when at least one event is
         ready.
        */
        auto PumpEvent() -> co::Co<PlatformEvent>;

        bool initialized_ { false };
        size_t aw_event_index_ { 0 };
        std::array<co::Shared<SharedProducer>, 2> aw_events_ {};

        co::ParkingLot wait_for_event_ {};
    };

    //! Exposes the input events generated by the platform to a __single__
    //! awaiting task.
    /*!
     Filters platform input events, and buffers them in a queue for consumption
     by a single task. The task, which must call `NextEvent()`, will be
     suspended unless or until an input event is available from the event queue.
    */
    class InputEvents : public Component {
        OXYGEN_COMPONENT(InputEvents)
        OXYGEN_COMPONENT_REQUIRES(EventPump)
    public:
        class Awaitable {
        public:
            friend class InputEvents;

            explicit Awaitable(InputEvents& object)
                : object_(object)
            {
            }
            [[nodiscard]] auto await_ready() const noexcept
            {
                auto ready = !object_.events_.empty();
                DLOG_F(INFO, "Input ready: {}, {}", ready, object_.events_.size());
                return ready;
            }
            void await_suspend(const co::detail::Handle h) { this->DoSuspend(h); }
            [[nodiscard]] auto await_resume() const
            {
                auto event = std::move(object_.events_.front());
                object_.events_.pop_front();
                return event;
            }

            auto await_cancel(co::detail::Handle) noexcept
            {
                handle_ = std::noop_coroutine();
                return std::true_type {};
            }

            friend class ParkingLotImpl;

        protected:
            [[nodiscard]] auto Object() -> InputEvents& { return object_; }
            [[nodiscard]] auto Object() const -> const InputEvents& { return object_; }

            void DoSuspend(const co::detail::Handle h)
            {
                handle_ = h;
                object_.parked_ = this;
            }

            void Resume()
            {
                std::exchange(handle_, std::noop_coroutine()).resume();
            }

        private:
            InputEvents& object_; // NOLINT(cppcoreguidelines-avoid-const-or-ref-data-members)
            co::detail::Handle handle_;
        };

        //! Suspends the caller until a platform input (keyboard, mouse,
        //! game-pad) event is available.
        auto operator co_await() -> co::Awaitable<int> auto
        {
            if (parked_ != nullptr) {
                LOG_F(ERROR, "Input events are already being awaited. Only one awaiter is allowed.");
                throw std::runtime_error("Only one awaiter on input events is allowed.");
            }
            return Awaitable(*this);
        }

    protected:
        void UpdateDependencies(const Composition& composition) override
        {
            event_pump_ = &composition.GetComponent<EventPump>();
            DCHECK_NOTNULL_F(event_pump_);
        }

    private:
        friend Platform;
        auto ProcessPlatformEvents() -> co::Co<>;
        void ResumeAwaiter()
        {
            if (parked_ != nullptr) {
                parked_->Resume();
                parked_ = nullptr;
            }
        }

        Awaitable* parked_;
        std::deque<int> events_;
        EventPump* event_pump_ { nullptr };
    };

    class WindowManager : public Component {
        OXYGEN_COMPONENT(WindowManager)
        OXYGEN_COMPONENT_REQUIRES(EventPump)
    public:
        auto MakeWindow() -> size_t;

        [[nodiscard]] auto LastWindowClosed() -> co::Event& { return last_window_closed_; }

    protected:
        void UpdateDependencies(const Composition& composition) override
        {
            event_pump_ = &composition.GetComponent<EventPump>();
            DCHECK_NOTNULL_F(event_pump_);
        }

    private:
        friend Platform;
        auto ProcessPlatformEvents() -> co::Co<>;

        EventPump* event_pump_ { nullptr };
        co::Event last_window_closed_;
    };
} // namespace platform

class Platform : public Composition {
public:
    Platform();

    auto Start(co::TaskStarted<> started = {}) -> co::Co<>
    {
        return OpenNursery(nursery_, std::move(started));
    }

    void Run();

    auto Async() const -> platform::AsyncOps& { return GetComponent<platform::AsyncOps>(); }
    auto Events() const -> platform::EventPump& { return GetComponent<platform::EventPump>(); }
    auto Input() const -> platform::InputEvents& { return GetComponent<platform::InputEvents>(); }
    auto Windows() const -> platform::WindowManager& { return GetComponent<platform::WindowManager>(); }

private:
    co::Nursery* nursery_ {};
};

} // namespace oxygen
