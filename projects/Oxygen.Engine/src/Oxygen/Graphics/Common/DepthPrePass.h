//===----------------------------------------------------------------------===//
// Distributed under the 3-Clause BSD License. See accompanying file LICENSE or
// copy at https://opensource.org/licenses/BSD-3-Clause.
// SPDX-License-Identifier: BSD-3-Clause
//===----------------------------------------------------------------------===//

#pragma once

#include <cassert>
#include <memory>
#include <optional>
#include <span>
#include <string>
#include <vector>

#include <Oxygen/Graphics/Common/RenderPass.h>
#include <Oxygen/Graphics/Common/api_export.h>

// TODO: #include <Oxygen/Graphics/Common/RenderItem.h> // Will be needed after RenderItem is defined

namespace oxygen::graphics {

class ResourceRegistry;
class ResourceStateTracker;
class CommandRecorder;
class Framebuffer;
class PipelineState;
class Texture; // Forward declare Texture

// Forward declaration for the items in the draw list
struct RenderItem;

//! Configuration for a depth pre-pass.
/*!
 Specifies the essential setup for a depth pre-pass, including the geometry to
 be rendered, the mandatory target depth texture, and an optional framebuffer
 object that can provide a broader rendering context.
*/
struct DepthPrePassConfig {
    //! List of mesh or draw call identifiers to render in the prepass.
    /*!
     In a Forward+ rendering pipeline, this list should contain all geometry
     that needs to contribute to the depth buffer for accurate light culling.
     This typically includes all opaque and alpha-tested geometry that will
     be rendered in the main shading pass. Consistent geometry and transformations
     between this pass and the main shading pass are crucial.
    */
    std::span<const RenderItem*> draw_list;

    //! The primary and authoritative depth target texture for this pass.
    /*!
     All depth information generated by this pass will be rendered into this
     specific texture. This field is mandatory.
    */
    std::shared_ptr<const Texture> depth_texture;

    //! Optional: A complete Framebuffer object for broader rendering context.
    /*!
     If provided, this Framebuffer can be used by backend implementations to
     satisfy API requirements (e.g., needing a full Framebuffer object for
     binding) or for coordinated resource management (e.g., calling
     `Framebuffer::PrepareForRender()` on it).

     For coherent behavior, if a `framebuffer` is supplied, its
     `depth_attachment.texture` should ideally refer to the same underlying
     texture resource as `depth_texture`. The `DepthPrePass` will always
     prioritize rendering to the `depth_texture` specified above.

     A `DepthPrePass` can be validly executed without a `framebuffer` (i.e.,
     when this is `nullptr`), rendering directly to the `depth_texture`.
    */
    std::shared_ptr<const Framebuffer> framebuffer = nullptr;
};

//! Backend-agnostic interface for a depth pre-pass.
/*!
 This class defines the interface for a depth pre-pass. In traditional
 rendering, this pass populates the depth buffer efficiently before main
 shading passes to leverage early depth testing, improving performance by
 avoiding redundant shading of occluded pixels.

 In a Forward+ rendering architecture, this pass serves a critical additional
 role: generating the depth information used by the light culling stage to
 determine which lights affect different parts of the scene.

 The DepthPrePass is configured via `DepthPrePassConfig`, which specifies the
 draw list (crucial for light culling in Forward+), the depth buffer to use,
 and an optional framebuffer. As a subclass of `RenderPass`, it integrates
 into the engine's coroutine-based render pipeline, allowing for asynchronous
 resource preparation and execution.
*/
class DepthPrePass : public RenderPass {
public:
    //! Configuration for the depth pre-pass.
    using Config = DepthPrePassConfig;

    //! Constructor for DepthPrePass.
    /*!
     \param name The name of this render pass.
     \param config The configuration settings for this depth pre-pass.
    */
    OXYGEN_GFX_API explicit DepthPrePass(std::string_view name, const Config& config);

    //! Destructor.
    ~DepthPrePass() override = default;

    OXYGEN_DEFAULT_COPYABLE(DepthPrePass)
    OXYGEN_DEFAULT_MOVABLE(DepthPrePass)

    //! Prepare and transition all resources needed for this pass.
    /*!
     The base implementation of this method ensures that the `depth_texture`
     (specified in `Config`) is transitioned to a state suitable for
     depth-stencil attachment (e.g., `ResourceStates::kDepthWrite`) using the
     provided `CommandRecorder`. It then flushes any pending resource barriers.

     Flushing barriers here is crucial to ensure the `depth_texture` is
     definitively in the `kDepthWrite` state before any subsequent operations
     by derived classes (e.g., clearing the texture) or later render stages.

     Backend-specific derived classes should call this base method and can then
     perform additional preparations, such as:
     - Interpreting `clear_color_` to derive depth and/or stencil clear values
       and applying them to the `depth_texture`.
     - Preparing the optional `framebuffer` if it's provided in `Config` and
       is relevant to the backend's operation (e.g., for binding or
       coordinated transitions).
    */
    OXYGEN_GFX_API co::Co<> PrepareResources(CommandRecorder& recorder) override;

    //! Execute the main rendering logic for this pass.
    /*!
     For a DepthPrePass, this involves rendering the geometry from the
     `draw_list` (specified in `Config`) to populate the `depth_texture`.
     Key responsibilities include:
     - Setting up a pipeline state configured for depth-only rendering
       (no color writes).
     - Applying the `viewport_` and `scissors_` if they have been set.
     - Issuing draw calls for the specified geometry.
    */
    co::Co<> Execute(CommandRecorder& recorder) override = 0;

    OXYGEN_GFX_API void SetViewport(const ViewPort& viewport) override;
    auto GetViewport() const -> std::optional<ViewPort> { return viewport_; }
    auto HasViewport() const -> bool { return viewport_.has_value(); }

    OXYGEN_GFX_API void SetScissors(const Scissors& scissors) override;
    auto GetScissors() const -> std::optional<Scissors> { return scissors_; }
    auto HasScissors() const -> bool { return scissors_.has_value(); }

    //! Sets the clear color for this render pass.
    /*!
     Note: For a depth pre-pass, this typically only affects the depth/stencil
     clear values, not color. The actual clear operation using these values
     should be handled within backend-specific `PrepareResources`
     implementations.
    */
    OXYGEN_GFX_API void SetClearColor(const Color& color) override;
    auto GetClearColor() const -> std::optional<Color> { return clear_color_; }
    auto HasClearColor() const -> bool { return clear_color_.has_value(); }

    OXYGEN_GFX_API virtual void SetEnabled(bool enabled) override;
    OXYGEN_GFX_API virtual auto IsEnabled() const -> bool override;

protected:
    //! Provides const access to the depth texture specified in the configuration.
    [[nodiscard]] auto GetDepthTexture() const -> const Texture&
    {
        assert(config_.depth_texture != nullptr && "Depth texture is null in GetDepthTexture");
        return *config_.depth_texture;
    }

    //! Provides const access to the draw list specified in the configuration.
    /*! \\return A span of const RenderItem pointers. The span itself is returned by value. */
    [[nodiscard]] auto GetDrawList() const -> std::span<const RenderItem*>
    {
        return config_.draw_list;
    }

    //! Provides const access to the framebuffer specified in the configuration, if any.
    /*!
     \\return A pointer to the const Framebuffer, or `nullptr` if no
              framebuffer is set in the configuration.
    */
    [[nodiscard]] auto GetFramebuffer() const -> const Framebuffer*
    {
        return config_.framebuffer.get();
    }

    //! Validates the current configuration.
    /*!
     This method is called by the constructor to ensure that the provided
     configuration is valid and consistent. Backend-specific implementations
     can override this to add further validation logic.
     Throws std::runtime_error if validation fails.
    */
    OXYGEN_GFX_API virtual void ValidateConfig();

    //! Configuration for the depth pre-pass.
    Config config_;

    //! Current viewport for the pass.
    std::optional<ViewPort> viewport_ {};

    //! Current scissor rectangle for the pass.
    std::optional<Scissors> scissors_ {};

    //! Current clear color for the pass (interpreted for depth/stencil).
    std::optional<Color> clear_color_ {}; // Default clear color (e.g., black, full alpha)

    //! Flag indicating if the pass is enabled.
    bool enabled_ = true;
};

} // namespace oxygen::graphics

/*
== Design Note: draw_list type in DepthPrePassConfig ==

The `draw_list` member of `DepthPrePassConfig` is currently `std::span<const
void*>`. This is a highly generic type that, while flexible, sacrifices type
safety and clarity. Backend implementations of `DepthPrePass::Execute` would
need to perform unsafe casts and make assumptions about the actual data being
pointed to.

Future Refinement: Ideally, `draw_list` should be a span of pointers to a more
concrete type that represents a renderable entity for the purpose of a depth
pass.

Recommended Alternatives (in order of preference, depending on engine
structure):

1. `std::span<const RenderItem*>` or `std::span<const Renderable*>`:
   - If a `RenderItem` or `Renderable` struct/class exists that encapsulates all
     necessary information for a draw call (e.g., Mesh, Transform, potentially
     instance data). This is a good high-level, object-oriented approach.
   - The `DepthPrePass` would primarily use the geometry and transformation
     aspects.

2. `std::span<const MeshInstance*>` (or similar e.g. `SceneObject*`,
   `RenderPrimitive*`):
   - If there's a type that specifically pairs a `Mesh` (geometry) with its
     world `Transform` and other relevant per-instance data for rendering, but
     is less comprehensive than a full `RenderItem` (e.g., might exclude
     material details not needed for depth-only rendering).

3. `std::span<const DrawCommand>`:
   - Where `DrawCommand` is a custom struct tailored for this pass, containing
     minimal data like `std::shared_ptr<const Mesh> mesh` and potentially
     transformation data if not handled globally or per-instance.

4. `std::span<const Mesh*>` (or `std::span<std::shared_ptr<const Mesh>>`):
   - If the pass operates primarily on raw mesh geometry, and transformations
     are managed externally (e.g., via a parallel list of transforms or a global
     instance buffer accessible during `Execute`). This is simpler but shifts
     transformation handling responsibility.

Considerations for choosing a type:
- Essential data for `Execute`: Geometry (vertex/index buffers, often via
  `Mesh`) and its world transformation.
- Type safety: Avoid `void*` to prevent runtime errors and improve code
  maintainability.
- Clarity: The type should clearly indicate what kind of entities are expected.
- Existing engine structures: Leverage existing types like `MeshInstance` or
  `RenderItem` if they fit the requirements.

For now, `std::span<const void*>` is a placeholder. When the higher-level scene
representation and render item management are more defined, this should be
revisited to use a more specific and type-safe alternative. The most suitable
choice will depend on how the engine structures its scene graph and prepares
lists of objects for rendering, particularly how meshes are associated with
their transformations.
*/
