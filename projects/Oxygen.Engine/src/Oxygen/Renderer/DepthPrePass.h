//===----------------------------------------------------------------------===//
// Distributed under the 3-Clause BSD License. See accompanying file LICENSE or
// copy at https://opensource.org/licenses/BSD-3-Clause.
// SPDX-License-Identifier: BSD-3-Clause
//===----------------------------------------------------------------------===//

#pragma once

#include <cassert>
#include <memory>
#include <optional>
#include <span>
#include <string>

#include <Oxygen/Graphics/Common/NativeObject.h>
#include <Oxygen/Graphics/Common/PipelineState.h>
#include <Oxygen/Graphics/Common/Types/Color.h>
#include <Oxygen/Graphics/Common/Types/Scissors.h>
#include <Oxygen/Graphics/Common/Types/ViewPort.h>
#include <Oxygen/Renderer/RenderPass.h>
#include <Oxygen/Renderer/api_export.h>

namespace oxygen::graphics {

class ResourceRegistry;
class ResourceStateTracker;
class CommandRecorder;
class Framebuffer;
class PipelineState;
class Texture;
class RenderController;
class Buffer;

} // namespace oxygen::graphics

namespace oxygen::engine {

// Forward declaration for the items in the draw list
struct RenderItem;

//! Configuration for a depth pre-pass.
/*!
 Specifies the essential setup for a depth pre-pass, including the geometry to
 be rendered, the mandatory target depth texture, and an optional framebuffer
 object that can provide a broader rendering context.
*/
struct DepthPrePassConfig {

  //! The primary and authoritative depth target texture for this pass.
  /*!
   All depth information generated by this pass will be rendered into this
   specific texture. This field is mandatory.
  */
  std::shared_ptr<const graphics::Texture> depth_texture;

  //! Optional: A complete Framebuffer object for broader rendering context.
  /*!
   If provided, this Framebuffer can be used by backend implementations to
   satisfy API requirements (e.g., needing a full Framebuffer object for
   binding) or for coordinated resource management (e.g., calling
   `Framebuffer::PrepareForRender()` on it).

   For coherent behavior, if a `framebuffer` is supplied, its
   `depth_attachment.texture` should ideally refer to the same underlying
   texture resource as `depth_texture`. The `DepthPrePass` will always
   prioritize rendering to the `depth_texture` specified above.

   A `DepthPrePass` can be validly executed without a `framebuffer` (i.e.,
   when this is `nullptr`), rendering directly to the `depth_texture`.
  */
  std::shared_ptr<const graphics::Framebuffer> framebuffer = nullptr;

  //! The constant buffer containing scene-wide constants (e.g., camera, frame
  //! data) for this pass.
  /*!
   This buffer must be provided for the depth pre-pass. It should be prepared
   and updated by the caller before the pass executes. It is bound directly as
   a root CBV (using its GPU virtual address) and does not require a
   descriptor in the descriptor heap. This field is mandatory.
  */
  std::shared_ptr<const graphics::Buffer> scene_constants;

  //! Optional name for debugging purposes.
  std::string debug_name { "DepthPrePass" };
};

//! Generic implementation for a depth pre-pass. Can be extended if needed with
//! custom behavior and backend-specific logic.
/*!
 This class defines the interface for a depth pre-pass, and the default
 implementation. In traditional rendering, this pass populates the depth buffer
 efficiently before main shading passes to leverage early depth testing,
 improving performance by avoiding redundant shading of occluded pixels.

 In a Forward+ rendering architecture, this pass serves a critical additional
 role: generating the depth information used by the light culling stage to
 determine which lights affect different parts of the scene.

 The DepthPrePass is configured via `DepthPrePassConfig`, which specifies the
 draw list (crucial for light culling in Forward+), the depth buffer to use, and
 an optional framebuffer. As a subclass of `RenderPass`, it integrates into the
 engine's coroutine-based render pipeline, allowing for asynchronous resource
 preparation and execution.
*/
class DepthPrePass : public RenderPass {
public:
  //! Configuration for the depth pre-pass.
  using Config = DepthPrePassConfig;

  //! Constructor for DepthPrePass.
  /*!
   The constructor creates the descriptor for the depth pre-pass pipeline
   state and validates the configuration provided in \p `config`. These steps
   use virtual methods to allow backend-specific implementations to customize,
   which are not resolved in the constructor. If this class is extended,
   derived classes must use the proper constructor, which takes a
   `GraphicsPipelineDesc` as an argument, and must call ValidateConfig(),
   theirs and the base class's implementation, to ensure the configuration is
   valid out of the constructor.

   \param config The configuration settings for this depth pre-pass.
  */
  OXGN_RNDR_API explicit DepthPrePass(std::shared_ptr<Config> config);

  //! Destructor.
  ~DepthPrePass() override = default;

  OXYGEN_DEFAULT_COPYABLE(DepthPrePass)
  OXYGEN_DEFAULT_MOVABLE(DepthPrePass)

  OXGN_RNDR_API auto SetViewport(const graphics::ViewPort& viewport) -> void;
  auto GetViewport() const -> std::optional<graphics::ViewPort>
  {
    return viewport_;
  }
  auto HasViewport() const -> bool { return viewport_.has_value(); }

  OXGN_RNDR_API auto SetScissors(const graphics::Scissors& scissors) -> void;
  auto GetScissors() const -> std::optional<graphics::Scissors>
  {
    return scissors_;
  }
  auto HasScissors() const -> bool { return scissors_.has_value(); }

  //! Sets the clear color for this render pass.
  /*!
   Note: For a depth pre-pass, this typically only affects the depth/stencil
   clear values, not color. The actual clear operation using these values
   should be handled within backend-specific `PrepareResources`
   implementations.
  */
  OXGN_RNDR_API auto SetClearColor(const graphics::Color& color) -> void;
  auto GetClearColor() const -> std::optional<graphics::Color>
  {
    return clear_color_;
  }
  auto HasClearColor() const -> bool { return clear_color_.has_value(); }

  OXGN_RNDR_API auto SetEnabled(bool enabled) -> void;
  OXGN_RNDR_API auto IsEnabled() const -> bool override;

protected:
  auto DoPrepareResources(graphics::CommandRecorder& recorder)
    -> co::Co<> override;
  auto DoExecute(graphics::CommandRecorder& recorder) -> co::Co<> override;
  auto ValidateConfig() -> void override;
  auto CreatePipelineStateDesc() -> graphics::GraphicsPipelineDesc override;
  auto NeedRebuildPipelineState() const -> bool override;

private:
  //! Provides const access to the depth texture specified in the configuration.
  [[nodiscard]] auto GetDepthTexture() const -> const graphics::Texture&
  {
    assert(config_ && config_->depth_texture != nullptr
      && "Depth texture is null in GetDepthTexture");
    return *config_->depth_texture;
  }

  //! List of mesh or draw call identifiers to render in the pre-pass.
  /*!
   In a Forward+ rendering pipeline, this list should contain all geometry
   that needs to contribute to the depth buffer for accurate light culling.
   This typically includes all opaque and alpha-tested geometry that will
   be rendered in the main shading pass. Consistent geometry and transformations
   between this pass and the main shading pass are crucial.
  */
  [[nodiscard]] auto GetDrawList() const
    -> std::span<const RenderItem> override;

  //! Provides const access to the framebuffer specified in the configuration,
  //! if any.
  [[nodiscard]] auto GetFramebuffer() const -> const graphics::Framebuffer*
  {
    return config_ && config_->framebuffer ? config_->framebuffer.get()
                                           : nullptr;
  }

  // Helper methods for Execute()
  virtual auto PrepareDepthStencilView(
    const graphics::Texture& depth_texture_ref) -> graphics::NativeObject;
  virtual auto ClearDepthStencilView(
    graphics::CommandRecorder& command_recorder,
    const graphics::NativeObject& dsv_handle) const -> void;
  virtual auto SetupRenderTargets(graphics::CommandRecorder& command_recorder,
    const graphics::NativeObject& dsv) const -> void;
  virtual auto SetupViewPortAndScissors(
    graphics::CommandRecorder& command_recorder) const -> void;
  virtual auto SetupSceneConstantsBuffer(
    graphics::CommandRecorder& command_recorder) const -> void;

  //! Configuration for the depth pre-pass.
  std::shared_ptr<Config> config_;

  //! Current viewport for the pass.
  std::optional<graphics::ViewPort> viewport_ {};

  //! Current scissor rectangle for the pass.
  std::optional<graphics::Scissors> scissors_ {};

  //! Current clear color for the pass (interpreted for depth/stencil).
  std::optional<graphics::Color>
    clear_color_ {}; // Default clear color (e.g., black, full alpha)

  //! Flag indicating if the pass is enabled.
  bool enabled_ = true;
};

} // namespace oxygen::engine
