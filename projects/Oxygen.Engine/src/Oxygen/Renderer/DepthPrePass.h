//===----------------------------------------------------------------------===//
// Distributed under the 3-Clause BSD License. See accompanying file LICENSE or
// copy at https://opensource.org/licenses/BSD-3-Clause.
// SPDX-License-Identifier: BSD-3-Clause
//===----------------------------------------------------------------------===//

#pragma once

#include <cassert>
#include <memory>
#include <optional>
#include <span>
#include <string>

#include <Oxygen/Graphics/Common/NativeObject.h>
#include <Oxygen/Graphics/Common/PipelineState.h>
#include <Oxygen/Graphics/Common/Types/Color.h>
#include <Oxygen/Graphics/Common/Types/Scissors.h>
#include <Oxygen/Graphics/Common/Types/ViewPort.h>
#include <Oxygen/Renderer/RenderPass.h>
#include <Oxygen/Renderer/api_export.h>

namespace oxygen::graphics {

class ResourceRegistry;
class ResourceStateTracker;
class CommandRecorder;
class Framebuffer;
class PipelineState;
class Texture;
class RenderController;
class Buffer;

} // namespace oxygen::graphics

namespace oxygen::engine {

// Forward declaration for the items in the draw list
struct RenderItem;

//! Configuration for a depth pre-pass.
/*!
 Specifies the essential setup for a depth pre-pass, including the geometry to
 be rendered, the mandatory target depth texture, and an optional framebuffer
 object that can provide a broader rendering context.
*/
struct DepthPrePassConfig {
  //! List of mesh or draw call identifiers to render in the pre-pass.
  /*!
   In a Forward+ rendering pipeline, this list should contain all geometry
   that needs to contribute to the depth buffer for accurate light culling.
   This typically includes all opaque and alpha-tested geometry that will
   be rendered in the main shading pass. Consistent geometry and transformations
   between this pass and the main shading pass are crucial.
  */
  std::span<const RenderItem*> draw_list;

  //! The primary and authoritative depth target texture for this pass.
  /*!
   All depth information generated by this pass will be rendered into this
   specific texture. This field is mandatory.
  */
  std::shared_ptr<const graphics::Texture> depth_texture;

  //! Optional: A complete Framebuffer object for broader rendering context.
  /*!
   If provided, this Framebuffer can be used by backend implementations to
   satisfy API requirements (e.g., needing a full Framebuffer object for
   binding) or for coordinated resource management (e.g., calling
   `Framebuffer::PrepareForRender()` on it).

   For coherent behavior, if a `framebuffer` is supplied, its
   `depth_attachment.texture` should ideally refer to the same underlying
   texture resource as `depth_texture`. The `DepthPrePass` will always
   prioritize rendering to the `depth_texture` specified above.

   A `DepthPrePass` can be validly executed without a `framebuffer` (i.e.,
   when this is `nullptr`), rendering directly to the `depth_texture`.
  */
  std::shared_ptr<const graphics::Framebuffer> framebuffer = nullptr;

  //! The constant buffer containing scene-wide constants (e.g., camera, frame
  //! data) for this pass.
  /*!
   This buffer must be provided for the depth pre-pass. It should be prepared
   and updated by the caller before the pass executes. It is bound directly as
   a root CBV (using its GPU virtual address) and does not require a
   descriptor in the descriptor heap. This field is mandatory.
  */
  std::shared_ptr<const graphics::Buffer> scene_constants;

  //! Optional name for debugging purposes.
  std::string debug_name { "DepthPrePass" };
};

//! Generic implementation for a depth pre-pass. Can be extended if needed with
//! custom behavior and backend-specific logic.
/*!
 This class defines the interface for a depth pre-pass, and the default
 implementation. In traditional rendering, this pass populates the depth buffer
 efficiently before main shading passes to leverage early depth testing,
 improving performance by avoiding redundant shading of occluded pixels.

 In a Forward+ rendering architecture, this pass serves a critical additional
 role: generating the depth information used by the light culling stage to
 determine which lights affect different parts of the scene.

 The DepthPrePass is configured via `DepthPrePassConfig`, which specifies the
 draw list (crucial for light culling in Forward+), the depth buffer to use, and
 an optional framebuffer. As a subclass of `RenderPass`, it integrates into the
 engine's coroutine-based render pipeline, allowing for asynchronous resource
 preparation and execution.
*/
class DepthPrePass : public RenderPass {
public:
  //! Configuration for the depth pre-pass.
  using Config = DepthPrePassConfig;

  //! Constructor for DepthPrePass.
  /*!
   The constructor creates the descriptor for the depth pre-pass pipeline
   state and validates the configuration provided in \p `config`. These steps
   use virtual methods to allow backend-specific implementations to customize,
   which are not resolved in the constructor. If this class is extended,
   derived classes must use the proper constructor, which takes a
   `GraphicsPipelineDesc` as an argument, and must call ValidateConfig(),
   theirs and the base class's implementation, to ensure the configuration is
   valid out of the constructor.

   \param renderer The renderer that creates this depth pre-pass.
   \param config The configuration settings for this depth pre-pass.
  */
  OXGN_RNDR_API DepthPrePass(
    graphics::RenderController* renderer, std::shared_ptr<Config> config);

  //! Destructor.
  ~DepthPrePass() override = default;

  OXYGEN_DEFAULT_COPYABLE(DepthPrePass)
  OXYGEN_DEFAULT_MOVABLE(DepthPrePass)

  //! Prepare and transition all resources needed for this pass.
  /*!
   The base implementation of this method ensures that the `depth_texture`
   (specified in `Config`) is transitioned to a state suitable for
   depth-stencil attachment (e.g., `ResourceStates::kDepthWrite`) using the
   provided `CommandRecorder`. It then flushes any pending resource barriers.

   Flushing barriers here is crucial to ensure the `depth_texture` is
   definitively in the `kDepthWrite` state before any subsequent operations by
   derived classes (e.g., clearing the texture) or later render stages.

   Backend-specific derived classes should call this base method and can then
   perform additional preparations, such as:
   - Interpreting `clear_color_` to derive depth and/or stencil clear values
     and applying them to the `depth_texture`.
   - Preparing the optional `framebuffer` if it's provided in `Config` and is
     relevant to the backend operation (e.g., for binding or coordinated
     transitions).
  */
  OXGN_RNDR_API auto PrepareResources(graphics::CommandRecorder& recorder)
    -> co::Co<> override;

  //! Execute the main rendering logic for this pass.
  /*!
   For a DepthPrePass, this involves rendering the geometry from the
   `draw_list` (specified in `Config`) to populate the `depth_texture`.
   Key responsibilities include:
   - Setting up a pipeline state configured for depth-only rendering
     (no color writes).
   - Applying the `viewport_` and `scissors_` if they have been set.
   - Issuing draw calls for the specified geometry.
  */
  auto Execute(graphics::CommandRecorder& command_recorder)
    -> co::Co<> override;

  OXGN_RNDR_API void SetViewport(const graphics::ViewPort& viewport) override;
  auto GetViewport() const -> std::optional<graphics::ViewPort>
  {
    return viewport_;
  }
  auto HasViewport() const -> bool { return viewport_.has_value(); }

  OXGN_RNDR_API void SetScissors(const graphics::Scissors& scissors) override;
  auto GetScissors() const -> std::optional<graphics::Scissors>
  {
    return scissors_;
  }
  auto HasScissors() const -> bool { return scissors_.has_value(); }

  //! Sets the clear color for this render pass.
  /*!
   Note: For a depth pre-pass, this typically only affects the depth/stencil
   clear values, not color. The actual clear operation using these values
   should be handled within backend-specific `PrepareResources`
   implementations.
  */
  OXGN_RNDR_API void SetClearColor(const graphics::Color& color) override;
  auto GetClearColor() const -> std::optional<graphics::Color>
  {
    return clear_color_;
  }
  auto HasClearColor() const -> bool { return clear_color_.has_value(); }

  OXGN_RNDR_API void SetEnabled(bool enabled) override;
  OXGN_RNDR_API auto IsEnabled() const -> bool override;

protected:
  DepthPrePass(graphics::RenderController* renderer,
    std::shared_ptr<Config> config,
    graphics::GraphicsPipelineDesc pipeline_desc)
    : RenderPass(config->debug_name)
    , config_(std::move(config))
    , renderer_(renderer)
    , last_built_pso_desc_(std::move(pipeline_desc))
  {
    // No call to ValidateConfig() here, as it should be called by the
    // derived class.
  }

  //! Provides const access to the depth texture specified in the configuration.
  [[nodiscard]] auto GetDepthTexture() const -> const graphics::Texture&
  {
    assert(config_ && config_->depth_texture != nullptr
      && "Depth texture is null in GetDepthTexture");
    return *config_->depth_texture;
  }

  //! Provides const access to the draw list specified in the configuration.
  [[nodiscard]] auto GetDrawList() const -> std::span<const RenderItem*>
  {
    assert(config_);
    return config_->draw_list;
  }

  //! Provides const access to the framebuffer specified in the configuration,
  //! if any.
  [[nodiscard]] auto GetFramebuffer() const -> const graphics::Framebuffer*
  {
    return config_ && config_->framebuffer ? config_->framebuffer.get()
                                           : nullptr;
  }

  //! Validates the current configuration.
  /*!
   This method is called by the constructor to ensure that the provided
   configuration is valid and consistent. Backend-specific implementations
   can override this to add further validation logic.
   Throws std::runtime_error if validation fails.
  */
  OXGN_RNDR_API virtual void ValidateConfig();

  virtual auto CreatePipelineStateDesc() -> graphics::GraphicsPipelineDesc;
  virtual auto NeedRebuildPipelineState() const -> bool;

  // Helper methods for Execute()
  virtual auto PrepareDepthStencilView(
    const graphics::Texture& depth_texture_ref) -> graphics::NativeObject;
  virtual void ClearDepthStencilView(
    graphics::CommandRecorder& command_recorder,
    const graphics::NativeObject& dsv_handle) const;
  virtual void SetViewAsRenderTarget(
    graphics::CommandRecorder& command_recorder,
    const graphics::NativeObject& dsv) const;
  virtual void SetupViewPortAndScissors(
    graphics::CommandRecorder& command_recorder) const;
  virtual void IssueDrawCalls(
    graphics::CommandRecorder& command_recorder) const;
  virtual void PrepareSceneConstantsBuffer(
    graphics::CommandRecorder& command_recorder) const;

private:
  //! Configuration for the depth pre-pass.
  std::shared_ptr<Config> config_;

  //! Current viewport for the pass.
  std::optional<graphics::ViewPort> viewport_ {};

  //! Current scissor rectangle for the pass.
  std::optional<graphics::Scissors> scissors_ {};

  //! Current clear color for the pass (interpreted for depth/stencil).
  std::optional<graphics::Color>
    clear_color_ {}; // Default clear color (e.g., black, full alpha)

  //! Flag indicating if the pass is enabled.
  bool enabled_ = true;

  //! Pointer to the renderer that created this depth pre-pass.
  graphics::RenderController* renderer_ { nullptr };

  // Track the last built pipeline state object (PSO) description and hash, so
  // we can properly manage their caching and retrieval.
  graphics::GraphicsPipelineDesc last_built_pso_desc_;
  size_t last_built_pso_hash_ { 0 };
};

} // namespace oxygen::engine

/*
== Design Note: draw_list type in DepthPrePassConfig ==

The `draw_list` member of `DepthPrePassConfig` is currently `std::span<const
void*>`. This is a highly generic type that, while flexible, sacrifices type
safety and clarity. Backend implementations of `DepthPrePass::Execute` would
need to perform unsafe casts and make assumptions about the actual data being
pointed to.

Future Refinement: Ideally, `draw_list` should be a span of pointers to a more
concrete type that represents a renderable entity for the purpose of a depth
pass.

Recommended Alternatives (in order of preference, depending on engine
structure):

1. `std::span<const RenderItem*>` or `std::span<const Renderable*>`:
   - If a `RenderItem` or `Renderable` struct/class exists that encapsulates all
     necessary information for a draw call (e.g., Mesh, Transform, potentially
     instance data). This is a good high-level, object-oriented approach.
   - The `DepthPrePass` would primarily use the geometry and transformation
     aspects.

2. `std::span<const MeshInstance*>` (or similar e.g. `SceneObject*`,
   `RenderPrimitive*`):
   - If there's a type that specifically pairs a `Mesh` (geometry) with its
     world `Transform` and other relevant per-instance data for rendering, but
     is less comprehensive than a full `RenderItem` (e.g., might exclude
     material details not needed for depth-only rendering).

3. `std::span<const DrawCommand>`:
   - Where `DrawCommand` is a custom struct tailored for this pass, containing
     minimal data like `std::shared_ptr<const Mesh> mesh` and potentially
     transformation data if not handled globally or per-instance.

4. `std::span<const Mesh*>` (or `std::span<std::shared_ptr<const Mesh>>`):
   - If the pass operates primarily on raw mesh geometry, and transformations
     are managed externally (e.g., via a parallel list of transforms or a global
     instance buffer accessible during `Execute`). This is simpler but shifts
     transformation handling responsibility.

Considerations for choosing a type:
- Essential data for `Execute`: Geometry (vertex/index buffers, often via
  `Mesh`) and its world transformation.
- Type safety: Avoid `void*` to prevent runtime errors and improve code
  maintainability.
- Clarity: The type should clearly indicate what kind of entities are expected.
- Existing engine structures: Leverage existing types like `MeshInstance` or
  `RenderItem` if they fit the requirements.

For now, `std::span<const void*>` is a placeholder. When the higher-level scene
representation and render item management are more defined, this should be
revisited to use a more specific and type-safe alternative. The most suitable
choice will depend on how the engine structures its scene graph and prepares
lists of objects for rendering, particularly how meshes are associated with
their transformations.
*/
