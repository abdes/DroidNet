//===----------------------------------------------------------------------===//
// Distributed under the 3-Clause BSD License. See accompanying file LICENSE or
// copy at https://opensource.org/licenses/BSD-3-Clause.
// SPDX-License-Identifier: BSD-3-Clause
//===----------------------------------------------------------------------===//

#include <Oxygen/Data/GeometryAsset.h>
#include <Oxygen/Data/MaterialAsset.h>
#include <Oxygen/Data/ProceduralMeshes.h>
#include <numbers>
#include <string_view>
#include <vector>

/*!
 Creates a new Mesh representing a torus (doughnut shape) centered at the
 origin, aligned along the Y axis. The torus is generated by sweeping a circle
 (minor radius) around a larger circle (major radius). Vertices are generated
 with positions, normals, texcoords, tangents, bitangents, and color.

 @param major_segments Number of segments around the main ring (minimum 3).
 @param minor_segments Number of segments around the tube (minimum 3).
 @param major_radius Radius from the center to the center of the tube.
 @param minor_radius Radius of the tube.
 @return Shared pointer to the immutable Mesh containing the torus
 geometry. Returns nullptr on invalid input. Never throws.

 ### Performance Characteristics

 - Time Complexity: O(major_segments * minor_segments)
 - Memory: Allocates space for (major_segments+1)*(minor_segments+1) vertices
 and 6*major_segments*minor_segments indices
 - Optimization: All data is constructed in-place and moved into the Mesh.

 ### Usage Examples

 ```cpp
// Create a torus mesh asset
auto torus = MakeTorusMeshAsset(32, 16, 1.0f, 0.25f);
for (const auto& v : torus->Vertices()) { ... }
 ```

 @note The default view covers the entire mesh. Submesh views can be created
       using Mesh::MakeView.
 @see Mesh, MeshView, Vertex
*/
auto oxygen::data::MakeTorusMeshAsset(unsigned int major_segments,
  unsigned int minor_segments, float major_radius, float minor_radius)
  -> std::optional<std::pair<std::vector<Vertex>, std::vector<uint32_t>>>
{
  if (major_segments < 3 || minor_segments < 3 || major_radius <= 0.0f
    || minor_radius <= 0.0f) {
    return std::nullopt;
  }
  constexpr float pi = std::numbers::pi_v<float>;
  std::vector<Vertex> vertices;
  std::vector<uint32_t> indices;
  for (unsigned int i = 0; i <= major_segments; ++i) {
    float major_theta
      = 2.0f * pi * static_cast<float>(i) / static_cast<float>(major_segments);
    float cos_major = std::cos(major_theta);
    float sin_major = std::sin(major_theta);
    glm::vec3 major_center
      = { major_radius * cos_major, 0.0f, major_radius * sin_major };
    for (unsigned int j = 0; j <= minor_segments; ++j) {
      float minor_theta = 2.0f * pi * static_cast<float>(j)
        / static_cast<float>(minor_segments);
      float cos_minor = std::cos(minor_theta);
      float sin_minor = std::sin(minor_theta);
      glm::vec3 pos
        = glm::vec3 { cos_major * (major_radius + minor_radius * cos_minor),
            minor_radius * sin_minor,
            sin_major * (major_radius + minor_radius * cos_minor) };
      glm::vec3 normal = glm::normalize(pos - major_center);
      glm::vec2 texcoord
        = { static_cast<float>(i) / static_cast<float>(major_segments),
            static_cast<float>(j) / static_cast<float>(minor_segments) };
      // Tangent = dP/du (derivative w.r.t. major angle u)
      glm::vec3 tangent
        = glm::vec3 { -sin_major * (major_radius + minor_radius * cos_minor),
            0.0f, cos_major * (major_radius + minor_radius * cos_minor) };
      // Bitangent = dP/dv (derivative w.r.t. minor angle v)
      glm::vec3 bitangent = glm::vec3 { -cos_major * minor_radius * sin_minor,
        minor_radius * cos_minor, -sin_major * minor_radius * sin_minor };
      // Orthonormalize tangent against normal (Gram-Schmidt) and normalize
      tangent = glm::normalize(tangent - normal * glm::dot(normal, tangent));
      // Recompute bitangent to ensure orthogonality and consistent handedness
      bitangent = glm::normalize(glm::cross(normal, tangent));
      vertices.push_back(Vertex {
        .position = pos,
        .normal = normal,
        .texcoord = texcoord,
        .tangent = tangent,
        .bitangent = bitangent,
        .color = { 1, 1, 1, 1 },
      });
    }
  }
  for (unsigned int i = 0; i < major_segments; ++i) {
    for (unsigned int j = 0; j < minor_segments; ++j) {
      uint32_t i0 = i * (minor_segments + 1) + j;
      uint32_t i1 = ((i + 1) % (major_segments + 1)) * (minor_segments + 1) + j;
      uint32_t i2 = i0 + 1;
      uint32_t i3 = i1 + 1;
      // Ensure triangle winding matches the vertex normal direction
      indices.push_back(i0);
      indices.push_back(i2);
      indices.push_back(i1);
      indices.push_back(i2);
      indices.push_back(i3);
      indices.push_back(i1);
    }
  }

  return { { std::move(vertices), std::move(indices) } };
}
