//===----------------------------------------------------------------------===//
// Distributed under the 3-Clause BSD License. See accompanying file LICENSE or
// copy at https://opensource.org/licenses/BSD-3-Clause.
// SPDX-License-Identifier: BSD-3-Clause
//===----------------------------------------------------------------------===//

#pragma once

#include "deque"
#include <array>
#include <memory>
#include <vector>

#include "Oxygen/Base/Macros.h"
#include "Oxygen/Base/Signals.h"
#include "Oxygen/OxCo/Co.h"
#include "Oxygen/OxCo/Event.h"
#include "Oxygen/OxCo/Nursery.h"
#include "Oxygen/OxCo/ParkingLot.h"
#include "Oxygen/OxCo/Shared.h"
#include "Oxygen/OxCo/asio.h"
#include "Oxygen/Platform/Display.h"
#include "Oxygen/Platform/InputEvent.h"
#include "Oxygen/Platform/PlatformEvent.h"
#include "Oxygen/Platform/Window.h"
#include "Oxygen/Platform/api_export.h"

namespace oxygen {

class Platform;

namespace platform {

    class AsyncOps : public Component {
        OXYGEN_COMPONENT(AsyncOps)
    public:
        //! A utility function, returning an awaitable suspending the caller for a
        //! specified duration. Suitable for use with `AnyOf()` etc.
        auto SleepFor(std::chrono::microseconds delay)
        {
            return co::SleepFor(io_, delay);
        }

        auto PollOne() -> size_t
        {
            return io_.poll();
        }

        auto Start(co::TaskStarted<> started = {}) -> co::Co<>
        {
            return OpenNursery(nursery_, std::move(started));
        }

        [[nodiscard]] auto Nursery() const -> co::Nursery&
        {
            DCHECK_NOTNULL_F(nursery_);
            return *nursery_;
        }

        [[nodiscard]] auto IsRunning() const { return nursery_ != nullptr; }

    private:
        asio::io_context io_;
        co::Nursery* nursery_ {};
    };

    class EventPump : public Component {
        OXYGEN_COMPONENT(EventPump)
    public:
        using SharedProducer = std::function<co::Co<PlatformEvent>()>;

        //! Called as part of the main loop to check for pending platform
        //! events, and if any are found, to remove and asynchronously process
        //! __only__ the next one.
        /*!
         \note This method is not asynchronous and needs to complete quickly.
               When at least one event is ready, it resumes `PumpEvents()`,
               which will do the actual processing asynchronously. This
               machinery is internal to the platform. Externally, interested
               parties should await the awaitable appropriate for the event type
               they are interested in.
        */
        OXYGEN_PLATFORM_API auto PollOne() -> bool;

        //! Suspends the caller until a platform event is available.
        /*!
         Uses a double-buffering technique to ensure that the event is not
         missed by all tasks waiting for it, and will allow the tasks that
         complete first to wait for the next event.
        */
        auto WaitForNextEvent() -> co::Awaitable<PlatformEvent> auto
        {
            if (!initialized_) {
                BootStrap();
            }
            return aw_events_[aw_event_index_];
        }

    private:
        void BootStrap(size_t index = 0)
        {
            DCHECK_F(index == 0 || index == 1);
            aw_event_index_ = index;
            aw_events_[aw_event_index_].~Shared();
            new (&aw_events_[aw_event_index_]) co::Shared<SharedProducer>(std::in_place,
                [this]() -> co::Co<PlatformEvent> {
                    co_return co_await PumpEvent();
                });
        }

        //! Waits for platform events, and when available, translates them into
        //! specific event types and awakes any tasks waiting for them.
        /*!
         This is the asynchronous part of the platform event processing. It is
         constantly waiting for platform events, and when one is available, it
         translates it into a specific event type and awakes any tasks waiting
         for it.

         This method is resumed by the `PollOne()` when at least one event is
         ready.
        */
        auto PumpEvent() -> co::Co<PlatformEvent>;

        bool initialized_ { false };
        size_t aw_event_index_ { 0 };
        std::array<co::Shared<SharedProducer>, 2> aw_events_ {};

        co::ParkingLot wait_for_event_ {};
    };

    //! Exposes the input events generated by the platform to a __single__
    //! awaiting task.
    /*!
     Filters platform input events, and buffers them in a queue for consumption
     by a single task. The task, which must call `NextEvent()`, will be
     suspended unless or until an input event is available from the event queue.
    */
    class InputEvents : public Component {
        OXYGEN_COMPONENT(InputEvents)
        OXYGEN_COMPONENT_REQUIRES(EventPump)
    public:
        friend Platform;

        class Awaitable {
        public:
            friend class InputEvents;

            explicit Awaitable(InputEvents& object)
                : object_(object)
            {
            }
            [[nodiscard]] auto await_ready() const noexcept
            {
                auto ready = !object_.events_.empty();
                DLOG_F(INFO, "Input ready: {}, {}", ready, object_.events_.size());
                return ready;
            }
            void await_suspend(const co::detail::Handle h) { this->DoSuspend(h); }
            [[nodiscard]] auto await_resume() const
            {
                auto event = std::move(object_.events_.front());
                object_.events_.pop_front();
                return event;
            }

            auto await_cancel(co::detail::Handle) noexcept
            {
                handle_ = std::noop_coroutine();
                return std::true_type {};
            }

            friend class ParkingLotImpl;

        protected:
            [[nodiscard]] auto Object() -> InputEvents& { return object_; }
            [[nodiscard]] auto Object() const -> const InputEvents& { return object_; }

            void DoSuspend(const co::detail::Handle h)
            {
                handle_ = h;
                object_.parked_ = this;
            }

            void Resume()
            {
                std::exchange(handle_, std::noop_coroutine()).resume();
            }

        private:
            InputEvents& object_; // NOLINT(cppcoreguidelines-avoid-const-or-ref-data-members)
            co::detail::Handle handle_;
        };

        //! Suspends the caller until a platform input (keyboard, mouse,
        //! game-pad) event is available.
        auto operator co_await() -> co::Awaitable<int> auto
        {
            if (parked_ != nullptr) {
                LOG_F(ERROR, "Input events are already being awaited. Only one awaiter is allowed.");
                throw std::runtime_error("Only one awaiter on input events is allowed.");
            }
            return Awaitable(*this);
        }

    protected:
        void UpdateDependencies(const Composition& composition) override
        {
            event_pump_ = &composition.GetComponent<EventPump>();
            DCHECK_NOTNULL_F(event_pump_);
        }

    private:
        auto ProcessPlatformEvents() -> co::Co<>;
        void ResumeAwaiter()
        {
            if (parked_ != nullptr) {
                parked_->Resume();
                parked_ = nullptr;
            }
        }

        Awaitable* parked_;
        std::deque<int> events_;
        EventPump* event_pump_ { nullptr };
    };

    class WindowManager : public Component {
        OXYGEN_COMPONENT(WindowManager)
        OXYGEN_COMPONENT_REQUIRES(AsyncOps, EventPump)
    public:
        OXYGEN_PLATFORM_API auto MakeWindow(const Window::Properties& props) -> std::weak_ptr<Window>;

        [[nodiscard]] auto LastWindowClosed() -> co::Event& { return last_window_closed_; }

    protected:
        void UpdateDependencies(const Composition& composition) override
        {
            async_ = &composition.GetComponent<AsyncOps>();
            DCHECK_NOTNULL_F(async_);
            event_pump_ = &composition.GetComponent<EventPump>();
            DCHECK_NOTNULL_F(event_pump_);
        }

    private:
        friend Platform;
        auto ProcessPlatformEvents() -> co::Co<>;

        [[nodiscard]] auto WindowFromId(WindowIdType window_id) const -> Window&;

        AsyncOps* async_ { nullptr };
        EventPump* event_pump_ { nullptr };
        co::Event last_window_closed_;

        std::vector<std::shared_ptr<Window>> windows_;
    };

} // namespace platform

class Platform : public Composition {
public:
    OXYGEN_PLATFORM_API Platform();
    OXYGEN_PLATFORM_API ~Platform() override;

    OXYGEN_MAKE_NON_COPYABLE(Platform)
    OXYGEN_MAKE_NON_MOVEABLE(Platform)

    auto Start(co::TaskStarted<> started = {}) const -> co::Co<>
    {
        return GetComponent<platform::AsyncOps>().Start(std::move(started));
    }

    OXYGEN_PLATFORM_API void Run();
    auto IsRunning() const -> bool { return GetComponent<platform::AsyncOps>().IsRunning(); }

    auto Async() const -> platform::AsyncOps& { return GetComponent<platform::AsyncOps>(); }
    auto Events() const -> platform::EventPump& { return GetComponent<platform::EventPump>(); }
    auto Input() const -> platform::InputEvents& { return GetComponent<platform::InputEvents>(); }
    auto Windows() const -> platform::WindowManager& { return GetComponent<platform::WindowManager>(); }

private:
    void Compose();
};

#if 0
namespace imgui {
    class ImGuiPlatformBackend;
} // namespace imgui

class PlatformBase {
public:
    OXYGEN_PLATFORM_API PlatformBase();
    virtual ~PlatformBase() = default;

    OXYGEN_MAKE_NON_COPYABLE(PlatformBase)
    OXYGEN_MAKE_NON_MOVEABLE(PlatformBase)

    // ---------------------------------------------------------------------------

#  if defined(OXYGEN_VULKAN)
    [[nodiscard]] virtual auto GetRequiredInstanceExtensions() const
        -> std::vector<const char*>
        = 0;
#  endif // OXYGEN_VULKAN

    // -- Displays ---------------------------------------------------------------

    [[nodiscard]] virtual auto Displays() const
        -> std::vector<std::unique_ptr<platform::Display>>
        = 0;

    [[nodiscard]] virtual auto DisplayFromId(
        const platform::Display::IdType& display_id) const
        -> std::unique_ptr<platform::Display>
        = 0;

    // -- Window Management ------------------------------------------------------

    virtual auto MakeWindow(std::string const& title, PixelExtent const& extent)
        -> std::weak_ptr<platform::Window>
        = 0;

    virtual auto MakeWindow(std::string const& title,
        PixelExtent const& extent,
        platform::Window::InitialFlags flags)
        -> std::weak_ptr<platform::Window>
        = 0;

    virtual auto MakeWindow(std::string const& title,
        PixelPosition const& position,
        PixelExtent const& extent)
        -> std::weak_ptr<platform::Window>
        = 0;

    virtual auto MakeWindow(std::string const& title,
        PixelPosition const& position,
        PixelExtent const& extent,
        platform::Window::InitialFlags flags)
        -> std::weak_ptr<platform::Window>
        = 0;

    // -- Events -----------------------------------------------------------------

    //! Poll the platform event loop to process one event, awaking and executing
    //! all async handlers waiting for that event.
    /*!
     The `PollOne()` method polls for at most one platform event, and executes
     all async handlers that are ready to run, without blocking.

     \return The number of async event handlers that were executed.
     */
    virtual auto PollOne() -> size_t = 0;

    auto InputEvent() -> co::ParkingLot& { return platform_input_; }
    auto LastWindowClosed() -> co::Event& { return last_window_closed_; }

    // -- Slots ------------------------------------------------------------------

    [[nodiscard]] auto OnLastWindowClosed() -> auto&
    {
        return on_last_window_closed_;
    }

    [[nodiscard]] auto OnWindowClosed() -> auto& { return on_window_closed_; }

    [[nodiscard]] auto OnDisplayConnected() -> auto&
    {
        return on_display_connected_;
    }

    [[nodiscard]] auto OnDisplayDisconnected() -> auto&
    {
        return on_display_disconnected_;
    }

    // To get the new orientation, find the display from its id and query its
    // orientation.
    [[nodiscard]] auto OnDisplayOrientationChanged() -> auto&
    {
        return on_display_orientation_changed_;
    }

    static void GetAllInputSlots(std::vector<platform::InputSlot>& out_keys);
    static OXYGEN_PLATFORM_API auto GetInputSlotForKey(platform::Key key) -> platform::InputSlot;

    auto GetInputCategoryDisplayName(std::string_view category_name) -> std::string_view;

    [[nodiscard]] virtual auto CreateImGuiBackend(platform::WindowIdType window_id) const
        -> std::unique_ptr<imgui::ImGuiPlatformBackend>
        = 0;

private:
    co::ParkingLot platform_input_;
    co::Event last_window_closed_;

    sigslot::signal<> on_last_window_closed_;
    sigslot::signal<platform::Window const&> on_window_closed_;

    sigslot::signal<platform::Display::IdType> on_display_connected_;
    sigslot::signal<platform::Display::IdType> on_display_disconnected_;
    sigslot::signal<platform::Display::IdType> on_display_orientation_changed_;
};

template <typename T>
class PlatformEvent {
public:
    [[nodiscard]] auto NativeEvent() const& { return native_event_; }
    [[nodiscard]] auto NativeEventPtr() { return &native_event_; }
    [[nodiscard]] auto IsHandled() const { return handled_; }
    void SetHandled() { handled_ = true; }

private:
    bool handled_ { false };
    T native_event_ {};
};

template <typename T>
class EventProducer {
public:
    auto Event() const& { return polled_event_; }

protected:
    std::optional<PlatformEvent<T>> polled_event_;
};
#endif

} // namespace oxygen
