// Distributed under the MIT License. See accompanying file LICENSE or copy
// at https://opensource.org/licenses/MIT.
// SPDX-License-Identifier: MIT

using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DroidNet.Aura.Settings;
using DroidNet.Config;
using DroidNet.Controls.Menus;
using DryIoc;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Oxygen.Editor.Documents;
using Oxygen.Editor.Runtime.Engine;
using Oxygen.Editor.WorldEditor.Controls;

namespace Oxygen.Editor.WorldEditor.Editors.Scene;

/// <summary>
/// ViewModel for the Scene Editor.
/// </summary>
public partial class SceneEditorViewModel : ObservableObject
{
    private readonly ILogger logger;
    private readonly ILoggerFactory? loggerFactory;
    private readonly IEngineService engineService;
    private readonly IContainer container;
    private IMenuSource? quickAddMenu;
    private SceneViewLayout? previousLayout;

    /// <summary>
    /// Initializes a new instance of the <see cref="SceneEditorViewModel"/> class.
    /// </summary>
    /// <param name="metadata">The scene document metadata.</param>
    /// <param name="engineService">Coordinates native engine usage for the document.</param>
    /// <param name="container">DI container used to create child services for viewports.</param>
    /// <param name="loggerFactory">The logger factory.</param>
    public SceneEditorViewModel(SceneDocumentMetadata metadata, IEngineService engineService, IContainer container, ILoggerFactory? loggerFactory = null)
    {
        this.engineService = engineService;
        this.loggerFactory = loggerFactory;
        this.Viewports = new ObservableCollection<ViewportViewModel>();
        this.Metadata = metadata;
        this.container = container;
        this.logger = (loggerFactory ?? NullLoggerFactory.Instance).CreateLogger("Oxygen.Editor.WorldEditor.Editors.Scene.SceneEditorViewModel");

        // Try to restore layout from metadata if present
        this.CurrentLayout = SceneViewLayout.OnePane;

        this.UpdateLayout(this.CurrentLayout);

        // RunAtFps is sourced directly from the engine service at runtime
        // (see property implementation). No constructor seeding required.
    }

    /// <summary>
    /// Gets or sets the scene document metadata.
    /// </summary>
    [ObservableProperty]
    public partial SceneDocumentMetadata Metadata { get; set; }

    /// <summary>
    /// Gets or sets the current layout of the viewports.
    /// </summary>
    [ObservableProperty]
    public partial SceneViewLayout CurrentLayout { get; set; }

    /// <summary>
    /// Gets the collection of active viewports.
    /// </summary>
    public ObservableCollection<ViewportViewModel> Viewports { get; }

    /// <summary>
    /// Gets the command that changes the current layout (generated by [RelayCommand]).
    /// </summary>
    /// <remarks>The command property is generated by CommunityToolkit [RelayCommand] applied to ChangeLayout method.</remarks>

    /// <summary>
    /// Menu source used by the top Add MenuButton for quickly adding scene items.
    /// </summary>
    public IMenuSource QuickAddMenu => this.quickAddMenu ??= this.BuildQuickAddMenu();

    /// <summary>
    /// Gets or sets run rate target in frames per second for the editor preview.
    /// Always reads the current value from <see cref="IEngineService"/>.
    /// </summary>
    public int RunAtFps
    {
        get
        {
            try
            {
                var raw = (int)this.engineService.GetEngineTargetFps();
                var max = (int)this.engineService.MaxTargetFps;
                return System.Math.Clamp(raw, 0, max);
            }
            catch (InvalidOperationException)
            {
                // Engine not created yet â€” return sensible default.
                return 60;
            }
        }

        set
        {
            try
            {
                // Clamp UI value to engine supported range before forwarding.
                var max = (int)this.engineService.MaxTargetFps;
                var clamped = System.Math.Clamp(value, 0, max);
                this.engineService.SetEngineTargetFps((uint)clamped);

                // Notify UI that the value may have changed (source of truth is the service).
                this.OnPropertyChanged(nameof(this.RunAtFps));
            }
            catch (InvalidOperationException ex)
            {
                this.logger?.LogWarning(ex, "Failed to set engine target FPS: {Message}", ex.Message);
            }
        }
    }

    /// <summary>
    /// Minimum allowed native logging verbosity value for the engine (e.g. -9).
    /// </summary>
    public int MinLoggingVerbosity => (int)this.engineService.MinLoggingVerbosity;

    /// <summary>
    /// Maximum allowed native logging verbosity value for the engine (e.g. +9).
    /// </summary>
    public int MaxLoggingVerbosity => (int)this.engineService.MaxLoggingVerbosity;

    /// <summary>
    /// Current native engine logging verbosity; sourced from the engine service.
    /// Setting writes to the native runtime through the service and is clamped
    /// to Min/Max.
    /// </summary>
    public int LoggingVerbosity
    {
        get
        {
            var raw = this.engineService.GetEngineLoggingVerbosity();
            return System.Math.Clamp(raw, this.MinLoggingVerbosity, this.MaxLoggingVerbosity);
        }
        set
        {
            var clamped = System.Math.Clamp(value, this.MinLoggingVerbosity, this.MaxLoggingVerbosity);
            this.engineService.SetEngineLoggingVerbosity(clamped);
            this.OnPropertyChanged(nameof(this.LoggingVerbosity));
        }
    }

    partial void OnCurrentLayoutChanging(SceneViewLayout value)
    {
        this.UpdateLayout(value);
    }

    private void UpdateLayout(SceneViewLayout targetLayout)
    {
        var metadata = this.Metadata ?? throw new InvalidOperationException("Scene metadata is not initialized.");
        metadata.Layout = targetLayout;

        var placements = SceneLayoutHelpers.GetPlacements(targetLayout);
        var requiredCount = placements.Count;

        // Adjust viewports count
        while (this.Viewports.Count < requiredCount)
        {
            var settings = this.container.Resolve<ISettingsService<IAppearanceSettings>>();
            var viewport = new ViewportViewModel(metadata.DocumentId, this.engineService, settings, this.loggerFactory);
            viewport.ToggleMaximizeCommand = new RelayCommand(() => this.ToggleMaximize(viewport));
            viewport.OnLayoutRequested = requestedLayout => this.ChangeLayoutCommand.Execute(requestedLayout);
            this.Viewports.Add(viewport);
        }

        while (this.Viewports.Count > requiredCount)
        {
            this.Viewports.RemoveAt(this.Viewports.Count - 1);
        }

        // Update IsMaximized state and metadata for all viewports
        for (var i = 0; i < this.Viewports.Count; i++)
        {
            var viewport = this.Viewports[i];
            viewport.IsMaximized = targetLayout == SceneViewLayout.OnePane && this.previousLayout != null;

            // The first viewport is considered the main camera
            viewport.UpdateLayoutMetadata(i, i == 0);
            viewport.OnLayoutRequested = requestedLayout => this.ChangeLayoutCommand.Execute(requestedLayout);
        }
    }

    private void ToggleMaximize(ViewportViewModel viewport)
    {
        if (this.CurrentLayout == SceneViewLayout.OnePane)
        {
            // Restore
            if (this.previousLayout != null)
            {
                this.CurrentLayout = this.previousLayout.Value;
                this.previousLayout = null;
            }
        }
        else
        {
            // Maximize
            this.previousLayout = this.CurrentLayout;
            this.CurrentLayout = SceneViewLayout.OnePane;

            // Move the maximized viewport to the first position so it stays visible
            var index = this.Viewports.IndexOf(viewport);
            if (index > 0)
            {
                this.Viewports.Move(index, 0);
            }
        }
    }

    [RelayCommand]
    private void ChangeLayout(SceneViewLayout layout)
    {
        this.CurrentLayout = layout;
    }

    [RelayCommand]
    private void Save()
    {
        // TODO: Hook up actual save logic (wired to document service). For now just log.
        this.logger?.LogInformation("Save requested for document {Document}", this.Metadata?.DocumentId);
    }

    [RelayCommand]
    private void LocateInContentBrowser()
    {
        // TODO: Implement locate in content browser (publish a message / call service). For now log.
        this.logger?.LogInformation("Locate-in-content-browser requested for document {Document}", this.Metadata?.DocumentId);
    }

    private IMenuSource BuildQuickAddMenu()
    {
        var builder = new MenuBuilder(this.loggerFactory);

        // Shapes submenu
        _ = builder.AddSubmenu("Shapes", shapes =>
        {
            _ = shapes.AddMenuItem("Sphere", new RelayCommand(() => this.AddPrimitive("Sphere")));
            _ = shapes.AddMenuItem("Cube", new RelayCommand(() => this.AddPrimitive("Cube")));
            _ = shapes.AddMenuItem("Cylinder", new RelayCommand(() => this.AddPrimitive("Cylinder")));
            _ = shapes.AddMenuItem("Cone", new RelayCommand(() => this.AddPrimitive("Cone")));
            _ = shapes.AddMenuItem("Plane", new RelayCommand(() => this.AddPrimitive("Plane")));
        });

        _ = builder.AddSeparator();

        // Lights submenu
        _ = builder.AddSubmenu("Lights", lights =>
        {
            _ = lights.AddMenuItem("Directional Light", new RelayCommand(() => this.AddLight("Directional")));
            _ = lights.AddMenuItem("Point Light", new RelayCommand(() => this.AddLight("Point")));
            _ = lights.AddMenuItem("Spot Light", new RelayCommand(() => this.AddLight("Spot")));
            _ = lights.AddMenuItem("Rect Light", new RelayCommand(() => this.AddLight("Rect")));
            _ = lights.AddMenuItem("Sky Light", new RelayCommand(() => this.AddLight("Sky")));
        });

        return builder.Build();
    }

    [RelayCommand]
    private void AddPrimitive(string kind)
    {
        this.logger?.LogInformation("Request to add primitive {Kind} to document {Document}", kind, this.Metadata?.DocumentId);

        // TODO: Implement real add logic via document/engine APIs.
    }

    [RelayCommand]
    private void AddLight(string kind)
    {
        this.logger?.LogInformation("Request to add light {Kind} to document {Document}", kind, this.Metadata?.DocumentId);

        // TODO: Implement real add logic via document/engine APIs.
    }
}
