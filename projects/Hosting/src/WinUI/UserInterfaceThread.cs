// Distributed under the MIT License. See accompanying file LICENSE or copy
// at https://opensource.org/licenses/MIT.
// SPDX-License-Identifier: MIT

using System.Diagnostics;
using System.Reactive.Concurrency;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.UI.Dispatching;
using Microsoft.UI.Xaml;
using WinRT;

namespace DroidNet.Hosting.WinUI;

/// <summary>
/// Implementation for a WinUI based UI thread. This class serves as a drop-in replacement for the
/// bootstrap code auto-generated by the WinUI XAML in the `Main` entry point.
/// </summary>
/// <param name="serviceProvider">
/// The Dependency Injector's <see cref="IServiceProvider" /> instance.
/// </param>
/// <param name="lifetime">
/// The host application lifetime. This should be provided by the DI container and is used when the
/// hosting context indicates that the UI and the host application lifetimes are linked.
/// </param>
/// <param name="context">
/// The UI service hosting context. This should be provided by the DI container and partially populated
/// with the configuration options for the UI thread.
/// </param>
/// <param name="loggerFactory">
/// Used to obtain a logger for this class. If not provided, a <see cref="NullLogger" /> will be
/// used instead.
/// </param>
public partial class UserInterfaceThread(
    IServiceProvider serviceProvider,
    IHostApplicationLifetime lifetime,
    HostingContext context,
    ILoggerFactory? loggerFactory) : BaseUserInterfaceThread<HostingContext>(
    lifetime,
    context,
    loggerFactory?.CreateLogger<UserInterfaceThread>() ?? MakeNullLogger())
{
    /// <inheritdoc />
    public override Task StopUserInterfaceAsync()
    {
        Debug.Assert(
            this.HostingContext.Application is not null,
            "Expecting the `Application` in the context to not be null.");

        TaskCompletionSource completion = new();
        _ = this.HostingContext.Dispatcher!.TryEnqueue(
            () =>
            {
                this.HostingContext.Application?.Exit();
                completion.SetResult();
            });
        return completion.Task;
    }

    /// <inheritdoc />
    protected override void BeforeStart() => ComWrappersSupport.InitializeComWrappers();

    /// <inheritdoc />
    protected override void DoStart() => Application.Start(
        _ =>
        {
            // Setup the HostingContext with the UI dispatcher queue, a
            // scheduler that can be used to observe observables on the UI
            // thread, and the application instance
            this.HostingContext.Dispatcher = DispatcherQueue.GetForCurrentThread();
            this.HostingContext.DispatcherScheduler = DispatcherQueueScheduler.Current;
            this.HostingContext.Application = serviceProvider.GetRequiredService<Application>();

            DispatcherQueueSynchronizationContext synchronizationContext = new(this.HostingContext.Dispatcher);
            SynchronizationContext.SetSynchronizationContext(synchronizationContext);

            /*
             * Here we can add code that initializes the UI before the main window is created and activated For example:
             * unhandled exception handlers, maybe instancing, activation, etc...
             */

            // NOTE: First window creation is to be handled in Application.OnLaunched()
        });

    private static ILogger MakeNullLogger() => NullLoggerFactory.Instance.CreateLogger<UserInterfaceThread>();
}
