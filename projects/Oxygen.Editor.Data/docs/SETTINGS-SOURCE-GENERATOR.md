# Settings Descriptor Source Generator Specification

## Overview

The Settings Source Generator automatically creates setting descriptors and registration code from properties marked with `[Persisted]` attributes, eliminating boilerplate and ensuring type safety between property declarations and their descriptors.

## Architecture

### Design Principles

1. **Convention over Configuration**: Minimal attributes, maximum inference
2. **Type Safety**: Generated descriptors match property types exactly
3. **Immutability**: Descriptors registered once via module initializer at assembly load
4. **Zero Runtime Cost**: All code generation happens at compile time

### Component Diagram

```
┌─────────────────────────────────┐
│   ModuleSettings Class          │
│   + [Persisted] Properties      │
│   + const string ModuleName     │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│   Source Generator              │
│   • Scans [Persisted] attrs     │
│   • Extracts validation attrs   │
│   • Generates descriptors       │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│   Generated .Generated.cs       │
│   • Descriptor class            │
│   • Module initializer          │
└─────────────────────────────────┘
```

## Input: Developer Code

```csharp
public sealed partial class ExampleSettings : ModuleSettings
{
    private new const string ModuleName = "Oxygen.Editor.Data.Example";

    public ExampleSettings() : base(ModuleName) { }

    [Persisted]
    [Display(Name = "Window Position", Description = "The position of the window")]
    [Category("Layout")]
    [PointBounds(0, int.MaxValue, 0, int.MaxValue, ErrorMessage = "Coordinates must be non-negative")]
    public Point WindowPosition { get; set; }

    [Persisted]
    [Display(Name = "Window Size")]
    [Category("Layout")]
    [SizeBounds(1, int.MaxValue, 1, int.MaxValue, ErrorMessage = "Dimensions must be positive")]
    public Size WindowSize { get; set; }
}
```

## Output: Generated Code

### File: `ExampleSettings.Generated.cs`

```csharp
// <auto-generated/>
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using Oxygen.Editor.Data.Settings;

namespace Oxygen.Editor.Data.Models;

public sealed partial class ExampleSettings
{
    internal static class Descriptors
    {
        public static readonly SettingDescriptor<Point> WindowPosition = new()
        {
            Key = new SettingKey<Point>(ModuleName, nameof(WindowPosition)),
            DisplayName = "Window Position",
            Description = "The position of the window",
            Category = "Layout",
            Validators = new ValidationAttribute[]
            {
                new PointBoundsAttribute(0, int.MaxValue, 0, int.MaxValue)
                {
                    ErrorMessage = "Coordinates must be non-negative"
                }
            },
        };

        public static readonly SettingDescriptor<Size> WindowSize = new()
        {
            Key = new SettingKey<Size>(ModuleName, nameof(WindowSize)),
            DisplayName = "Window Size",
            Description = null,
            Category = "Layout",
            Validators = new ValidationAttribute[]
            {
                new SizeBoundsAttribute(1, int.MaxValue, 1, int.MaxValue)
                {
                    ErrorMessage = "Dimensions must be positive"
                }
            },
        };
    }
}

file static class ExampleSettingsInitializer
{
    [System.Runtime.CompilerServices.ModuleInitializer]
    internal static void Initialize()
    {
        EditorSettingsManager.StaticProvider.Register(ExampleSettings.Descriptors.WindowPosition);
        EditorSettingsManager.StaticProvider.Register(ExampleSettings.Descriptors.WindowSize);
    }
}
```

## Generator Requirements

### 1. Class Discovery

**Must:**

- Find all non-abstract classes inheriting from `ModuleSettings`
- Class must be `partial`
- Class must define `private new const string ModuleName`

**Diagnostics:**

- Error if class not partial: `SETGEN001: ModuleSettings class must be declared partial`
- Error if ModuleName missing: `SETGEN002: Class must define 'private new const string ModuleName'`
- Error if ModuleName not const: `SETGEN003: ModuleName must be a compile-time constant`

### 2. Property Scanning

**Must:**

- Find all properties with `[Persisted]` attribute
- Property must be public
- Property must have both getter and setter
- Property type must be serializable

**Diagnostics:**

- Warning if property not public: `SETGEN101: [Persisted] property must be public`
- Warning if property read-only: `SETGEN102: [Persisted] property must have a setter`
- Error if type not serializable: `SETGEN103: Property type must be JSON-serializable`

### 3. Attribute Extraction

#### Display Attribute

```csharp
[Display(Name = "...", Description = "...")]
```

- Extract `Name` → `descriptor.DisplayName`
- Extract `Description` → `descriptor.Description`
- If missing: DisplayName = property name, Description = null

#### Category Attribute

```csharp
[Category("Layout")]
```

- Extract category string → `descriptor.Category`
- If missing: Category = null

#### Validation Attributes

```csharp
[Required(ErrorMessage = "...")]
[Range(1, 100, ErrorMessage = "...")]
[StringLength(50, MinimumLength = 5)]
[PointBounds(0, 1000, 0, 1000, ErrorMessage = "...")]
```

**Must:**

- Preserve all constructor parameters
- Preserve all property initializers (e.g., `ErrorMessage`)
- Generate as array: `new ValidationAttribute[] { ... }`
- Support multiple validators per property

**Diagnostics:**

- Warning if validator has no parameters: `SETGEN201: Validator with no constraints has no effect`

### 4. Descriptor Generation

**Rules:**

- Descriptor name = property name
- Descriptor type = `SettingDescriptor<T>` where T = property type
- Key module = `ModuleName` constant
- Key name = `nameof(PropertyName)`
- Descriptors nested in `internal static class Descriptors`

**Type Mapping:**

```csharp
// Property type → Descriptor type
public string Name { get; set; }
→ SettingDescriptor<string> Name

public Point Position { get; set; }
→ SettingDescriptor<Point> Position

public List<string> Tags { get; set; }
→ SettingDescriptor<List<string>> Tags
```

### 5. Module Initializer Generation

**Must:**

- Create file-scoped static class: `file static class {ClassName}Initializer`
- Annotate with `[ModuleInitializer]`
- Register all descriptors with `EditorSettingsManager.StaticProvider.Register(...)`
- One initializer per settings class

**Example:**

```csharp
file static class ExampleSettingsInitializer
{
    [System.Runtime.CompilerServices.ModuleInitializer]
    internal static void Initialize()
    {
        // One Register call per property
        EditorSettingsManager.StaticProvider.Register(ExampleSettings.Descriptors.WindowPosition);
        EditorSettingsManager.StaticProvider.Register(ExampleSettings.Descriptors.WindowSize);
    }
}
```

**Guarantees:**

- Initializer runs before `Main()` entry point
- Descriptors available before any application code runs
- Thread-safe registration via `ConcurrentDictionary`

## Error Handling

### Compilation Errors (Block Build)

- `SETGEN001`: Class not partial
- `SETGEN002`: ModuleName constant missing
- `SETGEN003`: ModuleName not const
- `SETGEN103`: Property type not serializable

### Warnings (Allow Build)

- `SETGEN101`: Non-public [Persisted] property
- `SETGEN102`: Read-only [Persisted] property
- `SETGEN201`: Validator with no constraints

## Testing Strategy

### Unit Tests (Generator)

```csharp
[Fact]
public void GeneratesDescriptorForPersistedProperty()
{
    var source = """
        public sealed partial class TestSettings : ModuleSettings
        {
            private new const string ModuleName = "Test";
            public TestSettings() : base(ModuleName) { }

            [Persisted]
            public string Name { get; set; }
        }
        """;

    var result = GenerateSource(source);

    Assert.Contains("SettingDescriptor<string> Name", result);
    Assert.Contains("Key = new SettingKey<string>(ModuleName, nameof(Name))", result);
}
```

### Integration Tests

```csharp
[TestMethod]
public async Task GeneratedDescriptor_IsRegistered()
{
    var mgr = new EditorSettingsManager(context);
    var descriptors = await mgr.GetDescriptorsByCategoryAsync();

    Assert.IsTrue(descriptors.Values.Any(d => d.Name == "WindowPosition"));
}

[TestMethod]
public async Task GeneratedValidator_IsExecuted()
{
    var mgr = new EditorSettingsManager(context);
    var descriptor = GetDescriptor<Point>("WindowPosition");

    var act = () => mgr.SaveSettingAsync(descriptor, new Point(-1, -1));

    await Assert.ThrowsExceptionAsync<SettingsValidationException>(act);
}
```

## Migration Path

### Phase 1: Manual Implementation (Current)

- Developers write `.Generated.cs` files manually
- Validates the pattern works correctly
- Tests verify expected behavior

### Phase 2: Generator Implementation

- Implement incremental source generator
- Match manual code output exactly
- Run tests against generated code

### Phase 3: Cleanup

- Remove manual `.Generated.cs` files
- Add analyzer to warn if manual files detected
- Update documentation

## Benefits

1. **Type Safety**: Compile-time validation that descriptors match properties
2. **No Boilerplate**: Developers only write property declarations
3. **Consistency**: Automatic naming conventions eliminate typos
4. **Performance**: Zero runtime reflection, module initializer runs once
5. **Maintainability**: Changes to properties automatically update descriptors

## Example: Before vs After

### Before (Manual)

```csharp
// MySettings.cs
public sealed partial class MySettings : ModuleSettings
{
    public Point WindowPosition { get; set; }
}

// MySettings.Generated.cs (manual)
public sealed partial class MySettings
{
    internal static class Descriptors
    {
        public static readonly SettingDescriptor<Point> WindowPosition = new()
        {
            Key = new SettingKey<Point>("MyModule", nameof(WindowPosition)),
            // ... 20 lines of boilerplate
        };
    }
}
```

### After (Generated)

```csharp
// MySettings.cs
public sealed partial class MySettings : ModuleSettings
{
    [Persisted]
    public Point WindowPosition { get; set; }
}

// MySettings.Generated.cs (auto-generated by compiler)
// ... descriptors + initializer generated automatically
```

## Future Enhancements

1. **Incremental Generation**: Only regenerate changed classes
2. **IDE Integration**: IntelliSense for descriptor names
3. **Analyzer**: Warn about duplicate setting names
4. **Code Fixes**: Auto-add `[Persisted]` attribute
5. **Documentation**: Generate XML docs for descriptors
