# Settings Descriptor Source Generator Specification

## Overview

The Settings Source Generator automatically creates setting descriptors and registration code from properties marked with `[Persisted]` attributes, eliminating boilerplate and ensuring type safety between property declarations and their descriptors.

### Scope & Goals

- Generate typed `SettingDescriptor<T>` fields for all `[Persisted]` properties on `ModuleSettings` subclasses.
- Emit a single file-scoped assembly-level module initializer that registers descriptors for the entire assembly with `EditorSettingsManager.StaticProvider` at assembly load.
- Preserve Display/Category metadata and validation attributes so the app and UI can use them for display and validation.
- Surface helpful diagnostics for common misuses so developers can fix issues quickly.

## Architecture

### Design Principles

1. **Convention over Configuration**: Minimal attributes, maximum inference
2. **Type Safety**: Generated descriptors match property types exactly
3. **Immutability**: Descriptors registered once via module initializer at assembly load
4. **Zero Runtime Cost**: All code generation happens at compile time

### Component Diagram

```text
┌─────────────────────────────────┐
│   ModuleSettings Class          │
│   + [Persisted] Properties      │
│   + const string ModuleName     │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│   Source Generator              │
│   • Scans [Persisted] attrs     │
│   • Extracts validation attrs   │
- Error if class not partial: `OXGNPG001: ModuleSettings class must be declared partial`
- Error if ModuleName missing: `OXGNPG002: Class must define 'private new const string ModuleName'`
- Error if ModuleName not const: `OXGNPG003: ModuleName must be a compile-time constant`
             ▼
┌─────────────────────────────────┐
│   Generated .Generated.cs       │
│   • Descriptor class            │
│   • Module initializer          │
└─────────────────────────────────┘
```

### Non-goals & Constraints

- The generator does not change runtime serialization behavior - it only generates descriptors that rely on `EditorSettingsManager` at runtime. The generator will not register runtime converters automatically — converters must be registered with the manager or available globally.
- The generator will not process private/internal property accessors; properties with non-public accessors will be emitted but generate a warning and may not be persisted at runtime.
- The generator does not generate UI code nor localizable strings beyond preserving `Display` attributes supplied by the developer.

### Supported serialization

- `EditorSettingsManager` uses `System.Text.Json` with `JsonSerializerOptions` contained in the manager. The generator requires that property types are serializable by `System.Text.Json` or that custom `JsonConverter` instances are available in the runtime configuration.
- For types requiring custom converters (e.g., `Point`, `Size`), rely on existing converters configured for the application or add converter types in `JsonSerializerOptions`.

## Input: Developer Code

```csharp
public sealed partial class ExampleSettings : ModuleSettings
{
    private new const string ModuleName = "Oxygen.Editor.Data.Example";

    public ExampleSettings() : base(ModuleName) { }

    [Persisted]
    [Display(Name = "Window Position", Description = "The position of the window")]
    [Category("Layout")]
    [PointBounds(0, int.MaxValue, 0, int.MaxValue, ErrorMessage = "Coordinates must be non-negative")]
    public Point WindowPosition { get; set; }

    [Persisted]
    [Display(Name = "Window Size")]
    [Category("Layout")]
    [SizeBounds(1, int.MaxValue, 1, int.MaxValue, ErrorMessage = "Dimensions must be positive")]
    public Size WindowSize { get; set; }
}

### Notes on usage
- Make the class `partial` so generated code can merge correctly.
- The generator uses `private new const string ModuleName` to build typed `SettingKey<T>` constants. The name must be a compile-time constant string literal.
- Properties decorated with `[Persisted]` must be `public`, have both getter and setter, and be JSON serializable.
```

## Output: Generated Code

### File: `ExampleSettings.Generated.cs`

```csharp
// <auto-generated/>
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using Oxygen.Editor.Data.Settings;

namespace Oxygen.Editor.Data.Models;

public sealed partial class ExampleSettings
{
    internal static class Descriptors
    {
        public static readonly SettingDescriptor<Point> WindowPosition = new()
        {
            Key = new SettingKey<Point>(ModuleName, nameof(WindowPosition)),
            DisplayName = "Window Position",
            Description = "The position of the window",
            Category = "Layout",
            Validators = new ValidationAttribute[]
            {
                new PointBoundsAttribute(0, int.MaxValue, 0, int.MaxValue)
                {
                    ErrorMessage = "Coordinates must be non-negative"
                }
            },
        };

        public static readonly SettingDescriptor<Size> WindowSize = new()
        {
            Key = new SettingKey<Size>(ModuleName, nameof(WindowSize)),
            DisplayName = "Window Size",
            Description = null,
            Category = "Layout",
            Validators = new ValidationAttribute[]
            {
                new SizeBoundsAttribute(1, int.MaxValue, 1, int.MaxValue)
                {
                    ErrorMessage = "Dimensions must be positive"
                }
            },
        };
    }
}

file static class DescriptorsInitializer
{
    [System.Runtime.CompilerServices.ModuleInitializer]
    internal static void Initialize()
    {
        EditorSettingsManager.StaticProvider.Register(Oxygen.Editor.Data.Models.ExampleSettings.Descriptors.WindowPosition);
        EditorSettingsManager.StaticProvider.Register(Oxygen.Editor.Data.Models.ExampleSettings.Descriptors.WindowSize);
    }
}
```

#### File and namespace conventions

- Generated files are named `{ClassName}.Generated.cs`. The generated code is placed in the same namespace as the original class.
- Descriptors are nested in an `internal static class Descriptors` declared within the original partial class so they are discoverable by `ModuleSettings` at runtime.
- The module initializer is `file static` to avoid naming collisions and to make the generated registration run as soon as the assembly loads.

## Generator Requirements

### 1. Class Discovery

**Must:**

- Find all non-abstract classes inheriting from `ModuleSettings`
- Class must be `partial`
- Class must define `private new const string ModuleName`

#### Implementation details

- The incremental source generator inspects `TypeDeclarationSyntax` nodes and builds a semantic model to check for `ModuleSettings` derivation, `partial` modifier, and presence of `ModuleName` constant.
- The generator emits diagnostics on the syntax/semantic nodes so the errors/warnings appear in the IDE.

**Diagnostics:**

- Error if class not partial: `OXGNPG001: ModuleSettings class must be declared partial`
- Error if ModuleName missing: `OXGNPG002: Class must define 'private new const string ModuleName'`
- Error if ModuleName not const: `OXGNPG003: ModuleName must be a compile-time constant`

### 2. Property Scanning

**Must:**

- Find all properties with `[Persisted]` attribute
- Property must be public
- Property must have both getter and setter
- Property type must be serializable

#### Supported property shapes

- Primitive types (string, numeric, bool), structs (e.g., `Point`, `Size`) and collections such as `List<T>` (where T itself is serializable) are supported when `System.Text.Json` can (de)serialize them.
- If a type requires a custom converter, ensure converters are registered in `EditorSettingsManager` `JsonSerializerOptions` or use a serializer wrapper accepted by the manager.

**Diagnostics:**

- Warning if property not public: `OXGNPG101: [Persisted] property must be public`
- Warning if property read-only: `OXGNPG102: [Persisted] property must have a setter`
- Error if type not serializable: `OXGNPG103: Property type must be JSON-serializable`
- Error if `[Persisted]` is used on a property inside a nested `ModuleSettings` class: `OXGNPG104: Nested ModuleSettings classes are not supported`

### 3. Attribute Extraction

#### Display Attribute

```csharp
[Display(Name = "...", Description = "...")]
```

- Extract `Name` → `descriptor.DisplayName`
- Extract `Description` → `descriptor.Description`
- If missing: DisplayName = property name, Description = null

#### Category Attribute

```csharp
[Category("Layout")]
```

- Extract category string → `descriptor.Category`
- If missing: Category = null

#### Validation Attributes

```csharp
[Required(ErrorMessage = "...")]
[Range(1, 100, ErrorMessage = "...")]
[StringLength(50, MinimumLength = 5)]
[PointBounds(0, 1000, 0, 1000, ErrorMessage = "...")]
```

**Must:**

- Preserve all constructor parameters
- Preserve all property initializers (e.g., `ErrorMessage`)
- Generate as array: `new ValidationAttribute[] { ... }`
- Support multiple validators per property

#### Implementation details

- The generator mirrors validator construction by preserving constructor arguments and property initializers (e.g., `ErrorMessage`) into the generated `ValidationAttribute` initializer. It does not attempt to interpret validation semantics at generation time; validation occurs at runtime when `EditorSettingsManager` calls validators during `SaveSettingAsync`.

**Diagnostics:**

- Warning if validator has no parameters: `OXGNPG201: Validator with no constraints has no effect`

### 4. Descriptor Generation

**Rules:**

- Descriptor name = property name
- Descriptor type = `SettingDescriptor<T>` where T = property type
- Key module = `ModuleName` constant
- Key name = `nameof(PropertyName)`
- Descriptors nested in `internal static class Descriptors`

#### Additional descriptor rules

- Generated descriptors include `DisplayName`, `Description`, `Category` and `Validators` from attributes. If Display `Name` or `Description` is not present, the generator uses `nameof(property)` and null respectively.
- When creating the `SettingKey<T>` we generate `new SettingKey<T>(ModuleName, nameof(Property))` to be robust to refactoring.

**Type Mapping:**

```csharp
// Property type → Descriptor type
public string Name { get; set; }
→ SettingDescriptor<string> Name

public Point Position { get; set; }
→ SettingDescriptor<Point> Position

public List<string> Tags { get; set; }
→ SettingDescriptor<List<string>> Tags
```

### 5. Module Initializer Generation

**Must:**

- Create file-scoped static class: `file static class {ClassName}Initializer`
- Annotate with `[ModuleInitializer]`
- Register all descriptors with `EditorSettingsManager.StaticProvider.Register(...)`
- One initializer per settings class

Implementation details

- The module initializer registers each generated `SettingDescriptor<T>` with `EditorSettingsManager.StaticProvider.Register(...)` so descriptors are available early in the app lifecycle.
- The generator avoids any runtime ordering assumptions: registration is idempotent and thread-safe thanks to `ConcurrentDictionary` usage in the provider.

**Example:**

```csharp
file static class ExampleSettingsInitializer
{
    [System.Runtime.CompilerServices.ModuleInitializer]
    internal static void Initialize()
    {
        // One Register call per property
        EditorSettingsManager.StaticProvider.Register(ExampleSettings.Descriptors.WindowPosition);
        EditorSettingsManager.StaticProvider.Register(ExampleSettings.Descriptors.WindowSize);
    }
}
```

**Guarantees:**

- Initializer runs before `Main()` entry point
- Descriptors available before any application code runs
- Thread-safe registration via `ConcurrentDictionary`

## Error Handling

### Compilation Errors (Block Build)

- `OXGNPG001`: Class not partial
- `OXGNPG002`: ModuleName constant missing
- `OXGNPG003`: ModuleName not const
- `OXGNPG103`: Property type not serializable

Diagnostic improvements (suggestions)

- When possible, provide a code fix suggestion: If a class is missing `partial`, offer a recommended quick fix to add `partial`. If `ModuleName` is missing, provide a template line for insertion: `private new const string ModuleName = "Your.Module.Name";`.
- Consider adding an analyzer to detect duplicate manual `.Generated.cs` files and suggest migration.

### Warnings (Allow Build)

- `OXGNPG101`: Non-public [Persisted] property
- `OXGNPG102`: Read-only [Persisted] property
- `OXGNPG201`: Validator with no constraints

## Testing Strategy

### Unit Tests (Generator)

```csharp
[Fact]
public void GeneratesDescriptorForPersistedProperty()
{
    var source = """
        public sealed partial class TestSettings : ModuleSettings
        {
            private new const string ModuleName = "Test";
            public TestSettings() : base(ModuleName) { }

            [Persisted]
            public string Name { get; set; }
        }
        """;

    var result = GenerateSource(source);

    Assert.Contains("SettingDescriptor<string> Name", result);
    Assert.Contains("Key = new SettingKey<string>(ModuleName, nameof(Name))", result);
}
```

#### Integration concerns

- The unit tests use Roslyn Source Generators test helpers to assert that generated code compiles and contains expected descriptors.
- Integration tests assert that `EditorSettingsManager.StaticProvider` contains descriptors and that validator attributes are executed at runtime when saving values.

### Integration Tests

```csharp
[TestMethod]
public async Task GeneratedDescriptor_IsRegistered()
{
    var mgr = new EditorSettingsManager(context);
    var descriptors = await mgr.GetDescriptorsByCategoryAsync();

    Assert.IsTrue(descriptors.Values.Any(d => d.Name == "WindowPosition"));
}

[TestMethod]
public async Task GeneratedValidator_IsExecuted()
{
    var mgr = new EditorSettingsManager(context);
    var descriptor = GetDescriptor<Point>("WindowPosition");

    var act = () => mgr.SaveSettingAsync(descriptor, new Point(-1, -1));

    await Assert.ThrowsExceptionAsync<SettingsValidationException>(act);
}
```

#### CI and developer testing

- Add generator tests to CI to run on every pull request; prefer running generator-specific tests separately for speed. They are present under `projects/Oxygen.Editor.Data/Generators/tests`.

## Migration Path

### Phase 1: Manual Implementation (Current)

- Developers write `.Generated.cs` files manually
- Validates the pattern works correctly
- Tests verify expected behavior

### Phase 2: Generator Implementation

- Implement incremental source generator
- Match manual code output exactly
- Run tests against generated code

### Phase 3: Cleanup

- Remove manual `.Generated.cs` files
- Add analyzer to warn if manual files detected
- Update documentation

#### Migration checklist

1. Remove manual `{ClassName}.Generated.cs` files after the generator is enabled and the project builds successfully.
2. Ensure custom validators and converters are registered at runtime (Json converters in `EditorSettingsManager.JsonSerializerOptions`).
3. Run integration tests to ensure descriptors are correctly discovered and validators executed as before.

## Benefits

1. **Type Safety**: Compile-time validation that descriptors match properties
2. **No Boilerplate**: Developers only write property declarations
3. **Consistency**: Automatic naming conventions eliminate typos
4. **Performance**: Zero runtime reflection, module initializer runs once
5. **Maintainability**: Changes to properties automatically update descriptors

## Example: Before vs After

### Before (Manual)

```csharp
// MySettings.cs
public sealed partial class MySettings : ModuleSettings
{
    public Point WindowPosition { get; set; }
}

// MySettings.Generated.cs (manual)
public sealed partial class MySettings
{
    internal static class Descriptors
    {
        public static readonly SettingDescriptor<Point> WindowPosition = new()
        {
            Key = new SettingKey<Point>("MyModule", nameof(WindowPosition)),
            // ... 20 lines of boilerplate
        };
    }
}
```

### After (Generated)

```csharp
// MySettings.cs
public sealed partial class MySettings : ModuleSettings
{
    [Persisted]
    public Point WindowPosition { get; set; }
}

// MySettings.Generated.cs (auto-generated by compiler)
// ... descriptors + initializer generated automatically
```

## Future Enhancements

1. **Incremental Generation**: Only regenerate changed classes
2. **IDE Integration**: IntelliSense for descriptor names
3. **Analyzer**: Warn about duplicate setting names
4. **Code Fixes**: Auto-add `[Persisted]` attribute
5. **Documentation**: Generate XML docs for descriptors
