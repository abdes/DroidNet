<?xml version="1.0" encoding="utf-8" ?>

<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"
         TreatAsLocalProperty="MyTopLevelDirectory;MyToolingDirectory">

    <PropertyGroup>
        <MyTopLevelDirectory>$([MSBuild]::EnsureTrailingSlash($(MSBuildThisFileDirectory)))</MyTopLevelDirectory>
        <MyToolingDirectory>$(MyTopLevelDirectory)tooling</MyToolingDirectory>
    </PropertyGroup>

    <!--
    This file is used to define properties shared across all projects within the
    monorepo. It is imported early in the build process. The properties here are
    NOT intended to be customized.
    -->

    <!-- https://learn.microsoft.com/en-us/dotnet/core/project-sdk/msbuild-props#package-properties -->
    <!-- Package Properties -->
    <PropertyGroup>
        <NeutralLanguage>en-US</NeutralLanguage>
    </PropertyGroup>

    <!-- Repo projects root : used in project references within the repo projects -->
    <PropertyGroup>
        <ProjectsRoot>$([MSBuild]::EnsureTrailingSlash($(MSBuildThisFileDirectory)))projects</ProjectsRoot>
    </PropertyGroup>

    <!-- Set default platform to x64 if not explicitly set -->
    <PropertyGroup>
        <Platform Condition="'$(Platform)' == '' OR '$(Platform)' == 'AnyCPU'">x64</Platform>
    </PropertyGroup>

    <!-- Read-only source tree (builds to top-level bin/obj folders)
         These default paths are disabled when UseArtifactsOutput is enabled
         (configured in Directory.build.props) because .NET 8+ will set output
         folders under the configured ArtifactsPath. -->
    <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true'">
        <!-- Don't include platform in base paths - the SDK will add it automatically to the final output path -->
        <BaseIntermediateOutputPath>$(MyTopLevelDirectory)obj\$([MSBuild]::MakeRelative($(MyTopLevelDirectory), $(MSBuildProjectDirectory)))\</BaseIntermediateOutputPath>
        <BaseOutputPath Condition=" '$(BaseOutputPath)' == '' ">$(MyTopLevelDirectory)bin\$([MSBuild]::MakeRelative($(MyTopLevelDirectory), $(MSBuildProjectDirectory)))\</BaseOutputPath>
    </PropertyGroup>

    <PropertyGroup>
        <!--
        We use TargetFrameworks even though we'e specifying a single TF here because in MSBuild, TF takes precedence over TFS.
        So, if a project wants to multi-target (e.g using EF Core tools), it will not be able to reference other projects in the
        repo because they single TF. So we use TargetFrameworks to allow multi-targeting.
        -->
        <SupportedOSPlatformVersion>10.0.17763.0</SupportedOSPlatformVersion>
        <TargetPlatformMinVersion>10.0.17763.0</TargetPlatformMinVersion>
        <Platforms>x64</Platforms>
    </PropertyGroup>

    <!-- Language Options -->
    <PropertyGroup>
        <LangVersion>preview</LangVersion>
        <Features>Strict</Features>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
        <EnforceExtendedAnalyzerRules>false</EnforceExtendedAnalyzerRules>
        <WarningLevel>999</WarningLevel>
        <NoWarn>$(NoWarn),1573,1591,1712</NoWarn>
        <WarningsAsErrors>nullable</WarningsAsErrors>
        <DefaultLanguage>en-US</DefaultLanguage>

        <AnalysisLevel>latest</AnalysisLevel>
        <AnalysisMode>All</AnalysisMode>
        <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Roslynator.Analyzers">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="Roslynator.CodeAnalysis.Analyzers">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="Roslynator.Formatting.Analyzers">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="Meziantou.Analyzer">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <PropertyGroup Condition="'$(GITHUB_ACTIONS)' == 'true'">
        <ContinuousIntegrationBuild>true</ContinuousIntegrationBuild>
        <!-- Local builds should embed PDBs so we never lose them when a subsequent build occurs. -->
        <DebugType>embedded</DebugType>
    </PropertyGroup>

    <!-- Package Options -->
    <PropertyGroup>
        <IsPackable>true</IsPackable>
        <IsPublishable>true</IsPublishable>
        <IncludeSymbols Condition=" '$(DebugType)' != 'embedded' ">true</IncludeSymbols>
        <SymbolPackageFormat>snupkg</SymbolPackageFormat>
        <PackageOutputPath>bin\Package</PackageOutputPath>
        <AllowedOutputExtensionsInPackageBuildOutputFolder>.pdb</AllowedOutputExtensionsInPackageBuildOutputFolder>
        <PublishRepositoryUrl>true</PublishRepositoryUrl>
    </PropertyGroup>
    <PropertyGroup>
        <PackageTags Condition="'$(PackageTags)' != ''">$(CommonTags);$(PackageTags)</PackageTags>
        <PackageTags Condition="'$(PackageTags)' == ''">$(CommonTags)</PackageTags>
    </PropertyGroup>
    <ItemGroup Condition="'$(Configuration)' == 'Release'">
        <PackageReference Include="NuGet.Build.Tasks.Pack" PrivateAssets="all" Pack="false" />
    </ItemGroup>

    <!-- Detect project README.md presence -->
    <!-- Typical project layout in this repository:
         projects/<ProjectName>/src/<ProjectName>.csproj
         Example: 'projects/Aura/src/Aura.csproj'

         Project-level README.md files live at the project root (next to the folder that contains 'src').
         Example README for the data layer: 'projects/Aura/README.md' -->
    <PropertyGroup>
        <_ProjectReadmePath>$(MSBuildProjectDirectory)\..\README.md</_ProjectReadmePath>
        <HasProjectReadme Condition="Exists('$(_ProjectReadmePath)')">true</HasProjectReadme>
    </PropertyGroup>

    <ItemGroup>
        <None Include="$([MSBUILD]::NormalizePath($(MyTopLevelDirectory), 'icon.png'))" Pack="true" PackagePath="\" />
        <None Include="$([MSBUILD]::NormalizePath($(MyTopLevelDirectory), 'LICENSE'))" Pack="true" PackagePath="\" />
        <!-- Include README.md from the project directory if present -->
        <None Include="$(_ProjectReadmePath)" Condition="'$(HasProjectReadme)' == 'true'" Pack="true" PackagePath="\" />
    </ItemGroup>

    <!-- If a project has a README.md, tell NuGet to use it as the package readme file -->
    <PropertyGroup Condition="'$(IsPackable)'=='True' AND '$(HasProjectReadme)' == 'true'">
        <PackageReadmeFile>README.md</PackageReadmeFile>
    </PropertyGroup>

    <!-- Workaround for the stupid intellisense in vscode not seeing the generated files for XAML -->
    <!-- Only include for design-time builds (IntelliSense), not for actual compilation -->
    <ItemGroup Condition="'$(BuildingInsideVisualStudio)' != 'True' AND '$(DesignTimeBuild)' == 'True'">
        <Compile Include="$(IntermediateOutputPath)\**\*.cs" AutoGen="True" />
    </ItemGroup>

    <ItemDefinitionGroup>
        <!-- We always want MSBuild properties generated that point at the restored location of each package. -->
        <!-- https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#generatepathproperty -->
        <PackageReference>
            <GeneratePathProperty>true</GeneratePathProperty>
        </PackageReference>
    </ItemDefinitionGroup>

    <!-- Build Options -->
    <PropertyGroup>
        <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>

        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <ProduceReferenceAssembly>true</ProduceReferenceAssembly>

        <!-- https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md#setplatform-negotiation -->
        <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>

        <Deterministic>false</Deterministic>
        <!-- This entire repo has just one version.json file, so compute the version once and share with all projects in a large build. -->
        <GitVersionBaseDirectory>$(MSBuildThisFileDirectory)</GitVersionBaseDirectory>

        <!-- Automatically install pre-commit hooks if not already done. Set to `false` in CI builds. -->
        <DN_PrecommitHooks>true</DN_PrecommitHooks>
    </PropertyGroup>
    <!-- In Release build, we want to specifically target the x64 platform -->
    <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
        <RuntimeIdentifiers>win-x64</RuntimeIdentifiers>
        <PlatformTarget>x64</PlatformTarget>
        <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Configuration)' == 'Release'">
        <Deterministic>true</Deterministic>
        <EmbedUntrackedSources>true</EmbedUntrackedSources>
        <AccelerateBuildsInVisualStudio>false</AccelerateBuildsInVisualStudio>
        <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
    </PropertyGroup>

    <!-- Test Projects -->
    <Choose>
        <When Condition="$(MSBuildProjectName.EndsWith('.Tests'))">
            <PropertyGroup>
                <IsTestProject>True</IsTestProject>
                <IsPackable>False</IsPackable>
            </PropertyGroup>
            <ItemGroup>
                <ProjectCapability Include="TestContainer" />
                <PackageReference Include="Microsoft.Testing.Extensions.CodeCoverage" />
                <PackageReference Include="AwesomeAssertions" />
                <PackageReference Include="AwesomeAssertions.Analyzers">
                    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
                    <PrivateAssets>all</PrivateAssets>
                </PackageReference>
            </ItemGroup>
            <ItemGroup>
                <ProjectReference Include="$(ProjectsRoot)\TestHelpers\src\TestHelpers.csproj" />
            </ItemGroup>
        </When>
    </Choose>
    <Choose>
        <When Condition="$(MSBuildProjectName.EndsWith('.Tests')) And !$(MSBuildProjectName.EndsWith('.UI.Tests'))">
            <PropertyGroup>
                <!-- Enable the MSTest runner, this is an opt-in feature -->
                <EnableMSTestRunner>true</EnableMSTestRunner>
                <!-- We need to produce an executable and not a DLL -->
                <OutputType>Exe</OutputType>
                <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>

                <!-- Code Coverage Settings -->
                <CodeCoverageEnabled>true</CodeCoverageEnabled>
            </PropertyGroup>
            <ItemGroup>
                <PackageReference Include="MSTest" />
            </ItemGroup>
        </When>
    </Choose>
    <Choose>
        <When Condition="$(MSBuildProjectName.EndsWith('.UI.Tests'))">
            <PropertyGroup>
                <UseWinUI>true</UseWinUI>
                <EnableMsixTooling>true</EnableMsixTooling>
                <!-- Disable until https://github.com/microsoft/testfx/issues/4056 is fixed -->
                <EnableMSTestRunner>false</EnableMSTestRunner>
                <GenerateTestingPlatformEntryPoint Condition=" '$(EnableMSTestRunner)' == 'true' ">false</GenerateTestingPlatformEntryPoint>
                <DefineConstants Condition=" '$(EnableMSTestRunner)' == 'true' ">$(DefineConstants);MSTEST_RUNNER</DefineConstants>
            </PropertyGroup>
            <ItemGroup>
                <PackageReference Include="Microsoft.WindowsAppSDK" />
                <PackageReference Include="Microsoft.Windows.SDK.BuildTools" />
                <PackageReference Include="Microsoft.TestPlatform.TestHost" Condition="'$(EnableMSTestRunner)' != 'true'" />
                <PackageReference Include="MSTest.Analyzers">
                    <PrivateAssets>all</PrivateAssets>
                    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
                </PackageReference>
                <PackageReference Include="MSTest.TestAdapter" />
                <PackageReference Include="MSTest.TestFramework" />
            </ItemGroup>
        </When>
    </Choose>

    <!-- WinUI Application Projects -->
    <Choose>
        <When Condition="$(MSBuildProjectName.EndsWith('.App')) Or $(MSBuildProjectName.EndsWith('.UI.Tests'))">
            <PropertyGroup>
                <IsPackable>false</IsPackable>
                <OutputType>WinExe</OutputType>
                <UseWinUI>true</UseWinUI>

                <!-- The App is Packaged, unless we're running a GitHub workflow -->
                <WindowsPackageType Condition="'$(GITHUB_ACTIONS)'=='true'">None</WindowsPackageType>
                <!-- Keep this for dotnet build CLI, although not needed for MSBuild -->
                <EnableMsixTooling>true</EnableMsixTooling>
                <WindowsAppSDKSelfContained>true</WindowsAppSDKSelfContained>
                <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
                <ApplicationManifest>Properties\app.manifest</ApplicationManifest>
                <RuntimeIdentifier>win-x64</RuntimeIdentifier>
                <PublishProfile>$(RuntimeIdentifier).pubxml</PublishProfile>
                <EnableMsixTooling>true</EnableMsixTooling>
            </PropertyGroup>
            <ItemGroup>
                <Manifest Include="$(ApplicationManifest)" />
            </ItemGroup>
        </When>
        <When Condition="$(MSBuildProjectName.EndsWith('.App')) And !$(MSBuildProjectName.EndsWith('.UI.Tests'))">
            <PropertyGroup>
                <!-- For the debug symbols package -->
                <DebugType>portable</DebugType>
            </PropertyGroup>
        </When>
    </Choose>

</Project>
